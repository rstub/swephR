diff --git a/src/libswe/swecl.c b/src/libswe/swecl.c
index 487efa8..81a57f3 100644
--- a/src/libswe/swecl.c
+++ b/src/libswe/swecl.c
@@ -511,7 +511,7 @@ struct saros_data saros_data_lunar[NSAROS_LUNAR] = {
  * all of these errors can grow up to a km or more. 
  * 
  * Function returns:
- * -1 (ERR)	on error (e.g. if swe_calc() for sun or moon fails)
+ * -1 (SE_ERR)	on error (e.g. if swe_calc() for sun or moon fails)
  * 0		if there is no solar eclipse at tjd
  * SE_ECL_TOTAL
  * SE_ECL_ANNULAR
@@ -575,7 +575,7 @@ int32 CALL_CONV swe_sol_eclipse_where(
   swi_set_tid_acc(tjd_ut, ifl, 0, serr);
   if ((retflag = eclipse_where(tjd_ut, SE_SUN, NULL, ifl, geopos, dcore, serr)) < 0)
     return retflag;
-  if ((retflag2 = eclipse_how(tjd_ut, SE_SUN, NULL, ifl, geopos[0], geopos[1], 0, attr, serr)) == ERR)
+  if ((retflag2 = eclipse_how(tjd_ut, SE_SUN, NULL, ifl, geopos[0], geopos[1], 0, attr, serr)) == SE_ERR)
     return retflag2;
   attr[3] = dcore[0];
   return retflag;
@@ -623,7 +623,7 @@ int32 CALL_CONV swe_lun_occult_where(
     ipl = SE_PLUTO;
   if ((retflag = eclipse_where(tjd_ut, ipl, starname, ifl, geopos, dcore, serr)) < 0)
     return retflag;
-  if ((retflag2 = eclipse_how(tjd_ut, ipl, starname, ifl, geopos[0], geopos[1], 0, attr, serr)) == ERR)
+  if ((retflag2 = eclipse_how(tjd_ut, ipl, starname, ifl, geopos[0], geopos[1], 0, attr, serr)) == SE_ERR)
     return retflag2;
   attr[3] = dcore[0];
   return retflag;
@@ -670,16 +670,16 @@ static int32 eclipse_where( double tjd_ut, int32 ipl, char *starname, int32 ifl,
   deltat = swe_deltat_ex(tjd_ut, ifl, serr);
   tjd = tjd_ut + deltat;
   /* moon in cartesian coordinates */
-  if ((retc = swe_calc(tjd, SE_MOON, iflag, rm, serr)) == ERR)
+  if ((retc = swe_calc(tjd, SE_MOON, iflag, rm, serr)) == SE_ERR)
     return retc;
   /* moon in polar coordinates */
-  if ((retc = swe_calc(tjd, SE_MOON, iflag2, lm, serr)) == ERR)
+  if ((retc = swe_calc(tjd, SE_MOON, iflag2, lm, serr)) == SE_ERR)
     return retc;
   /* sun in cartesian coordinates */
-  if ((retc = calc_planet_star(tjd, ipl, starname, iflag, rs, serr)) == ERR)
+  if ((retc = calc_planet_star(tjd, ipl, starname, iflag, rs, serr)) == SE_ERR)
     return retc;
   /* sun in polar coordinates */
-  if ((retc = calc_planet_star(tjd, ipl, starname, iflag2, ls, serr)) == ERR)
+  if ((retc = calc_planet_star(tjd, ipl, starname, iflag2, ls, serr)) == SE_ERR)
     return retc;
   /* save sun position */
   for (i = 0; i <= 2; i++)
@@ -934,20 +934,20 @@ int32 CALL_CONV swe_sol_eclipse_how(
   if (geopos[2] < SEI_ECL_GEOALT_MIN || geopos[2] > SEI_ECL_GEOALT_MAX) {
     if (serr != NULL)
       sprintf(serr, "location for eclipses must be between %.0f and %.0f m above sea", SEI_ECL_GEOALT_MIN, SEI_ECL_GEOALT_MAX);
-    return ERR;
+    return SE_ERR;
   }
   ifl &= SEFLG_EPHMASK; 
   swi_set_tid_acc(tjd_ut, ifl, 0, serr);
-  if ((retflag = eclipse_how(tjd_ut, SE_SUN, NULL, ifl, geopos[0], geopos[1], geopos[2], attr, serr)) == ERR)
+  if ((retflag = eclipse_how(tjd_ut, SE_SUN, NULL, ifl, geopos[0], geopos[1], geopos[2], attr, serr)) == SE_ERR)
     return retflag;
-  if ((retflag2 = eclipse_where(tjd_ut, SE_SUN, NULL, ifl, geopos2, dcore, serr)) == ERR)
+  if ((retflag2 = eclipse_where(tjd_ut, SE_SUN, NULL, ifl, geopos2, dcore, serr)) == SE_ERR)
     return retflag2;
   if (retflag)
     retflag |= (retflag2 & (SE_ECL_CENTRAL | SE_ECL_NONCENTRAL));
   attr[3] = dcore[0];
   swe_set_topo(geopos[0], geopos[1], geopos[2]);
-  if (swe_calc_ut(tjd_ut, SE_SUN, ifl | SEFLG_TOPOCTR | SEFLG_EQUATORIAL, ls, serr) == ERR)
-    return ERR;
+  if (swe_calc_ut(tjd_ut, SE_SUN, ifl | SEFLG_TOPOCTR | SEFLG_EQUATORIAL, ls, serr) == SE_ERR)
+    return SE_ERR;
   swe_azalt(tjd_ut, SE_EQU2HOR, geopos, 0, 10, ls, xaz);
   attr[4] = xaz[0];
   attr[5] = xaz[1];
@@ -990,14 +990,14 @@ static int32 eclipse_how( double tjd_ut, int32 ipl, char *starname, int32 ifl,
   geopos[2] = geohgt;
   te = tjd_ut + swe_deltat_ex(tjd_ut, ifl, serr);
   swe_set_topo(geolon, geolat, geohgt);
-  if (calc_planet_star(te, ipl, starname, iflag, ls, serr) == ERR)
-    return ERR;
-  if (swe_calc(te, SE_MOON, iflag, lm, serr) == ERR)
-    return ERR;
-  if (calc_planet_star(te, ipl, starname, iflagcart, xs, serr) == ERR)
-    return ERR;
-  if (swe_calc(te, SE_MOON, iflagcart, xm, serr) == ERR)
-    return ERR;
+  if (calc_planet_star(te, ipl, starname, iflag, ls, serr) == SE_ERR)
+    return SE_ERR;
+  if (swe_calc(te, SE_MOON, iflag, lm, serr) == SE_ERR)
+    return SE_ERR;
+  if (calc_planet_star(te, ipl, starname, iflagcart, xs, serr) == SE_ERR)
+    return SE_ERR;
+  if (swe_calc(te, SE_MOON, iflagcart, xm, serr) == SE_ERR)
+    return SE_ERR;
   /*
    * radius of planet disk in AU
    */
@@ -1210,12 +1210,12 @@ int32 CALL_CONV swe_sol_eclipse_when_glob(double tjd_start, int32 ifl, int32 ifl
   if (ifltype == (SE_ECL_PARTIAL | SE_ECL_CENTRAL)) {
     if (serr != NULL)
       strcpy(serr, "central partial eclipses do not exist");
-    return ERR;
+    return SE_ERR;
   }
   if (ifltype == (SE_ECL_ANNULAR_TOTAL | SE_ECL_NONCENTRAL)) {
     if (serr != NULL)
       strcpy(serr, "non-central hybrid (annular-total) eclipses do not exist");
-    return ERR;
+    return SE_ERR;
   }
   if (ifltype == 0)
     ifltype = SE_ECL_TOTAL | SE_ECL_ANNULAR | SE_ECL_PARTIAL
@@ -1278,14 +1278,14 @@ next_try:
        dt > 0.0001; 
        dt /= dtdiv) {
     for (i = 0, t = tjd - dt; i <= 2; i++, t += dt) {
-      if (swe_calc(t, SE_SUN, iflag, ls, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_MOON, iflag, lm, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_SUN, iflagcart, xs, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == ERR)
-        return ERR;
+      if (swe_calc(t, SE_SUN, iflag, ls, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_MOON, iflag, lm, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_SUN, iflagcart, xs, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == SE_ERR)
+        return SE_ERR;
       for (m = 0; m < 3; m++) {
         xa[m] = xs[m] / ls[2];
         xb[m] = xm[m] / lm[2];
@@ -1301,13 +1301,13 @@ next_try:
   tjds = tjd - swe_deltat_ex(tjd, ifl, serr);
   tjds = tjd - swe_deltat_ex(tjds, ifl, serr);
   tjds = tjd = tjd - swe_deltat_ex(tjds, ifl, serr);
-  if ((retflag = eclipse_where(tjd, SE_SUN, NULL, ifl, geopos, dcore, serr)) == ERR)
+  if ((retflag = eclipse_where(tjd, SE_SUN, NULL, ifl, geopos, dcore, serr)) == SE_ERR)
     return retflag;
   retflag2 = retflag;
     /* in extreme cases _where() returns no eclipse, where there is
      * actually a very small one, therefore call _how() with the
      * coordinates returned by _where(): */
-  if ((retflag2 = eclipse_how(tjd, SE_SUN, NULL, ifl, geopos[0], geopos[1], 0, attr, serr)) == ERR)
+  if ((retflag2 = eclipse_how(tjd, SE_SUN, NULL, ifl, geopos[0], geopos[1], 0, attr, serr)) == SE_ERR)
     return retflag2;
   if (retflag2 == 0) {
     K += direction;
@@ -1323,7 +1323,7 @@ next_try:
    * eclipse type, SE_ECL_TOTAL, _ANNULAR, etc.
    * SE_ECL_ANNULAR_TOTAL will be discovered later
    */
-  if ((retflag = eclipse_where(tjd, SE_SUN, NULL, ifl, geopos, dcore, serr)) == ERR)
+  if ((retflag = eclipse_where(tjd, SE_SUN, NULL, ifl, geopos, dcore, serr)) == SE_ERR)
     return retflag;
   if (retflag == 0) {	/* can happen with extremely small percentage */
     retflag = SE_ECL_PARTIAL | SE_ECL_NONCENTRAL;
@@ -1387,7 +1387,7 @@ next_try:
       i1 = 6; i2 = 7;
     }
     for (i = 0, t = tjd - dta; i <= 2; i += 1, t += dta) {
-      if ((retflag2 = eclipse_where(t, SE_SUN, NULL, ifl, geopos, dcore, serr)) == ERR)
+      if ((retflag2 = eclipse_where(t, SE_SUN, NULL, ifl, geopos, dcore, serr)) == SE_ERR)
         return retflag2;
       if (n == 0)
         dc[i] = dcore[4] / 2 + de / dcore[5] - dcore[2];
@@ -1402,7 +1402,7 @@ next_try:
     for (m = 0, dt = dtb; m < 3; m++, dt /= 3) {
       for (j = i1; j <= i2; j += (i2 - i1)) {
         for (i = 0, t = tret[j] - dt; i < 2; i++, t += dt) {
-          if ((retflag2 = eclipse_where(t, SE_SUN, NULL, ifl, geopos, dcore, serr)) == ERR)
+          if ((retflag2 = eclipse_where(t, SE_SUN, NULL, ifl, geopos, dcore, serr)) == SE_ERR)
             return retflag2;
           if (n == 0)
             dc[i] = dcore[4] / 2 + de / dcore[5] - dcore[2];
@@ -1420,13 +1420,13 @@ next_try:
    * annular-total eclipses
    */
   if (retflag & SE_ECL_TOTAL) {
-    if ((retflag2 = eclipse_where(tret[0], SE_SUN, NULL, ifl, geopos, dcore, serr)) == ERR)
+    if ((retflag2 = eclipse_where(tret[0], SE_SUN, NULL, ifl, geopos, dcore, serr)) == SE_ERR)
       return retflag2;
     dc[0] = *dcore;
-    if ((retflag2 = eclipse_where(tret[4], SE_SUN, NULL, ifl, geopos, dcore, serr)) == ERR)
+    if ((retflag2 = eclipse_where(tret[4], SE_SUN, NULL, ifl, geopos, dcore, serr)) == SE_ERR)
       return retflag2;
     dc[1] = *dcore;
-    if ((retflag2 = eclipse_where(tret[5], SE_SUN, NULL, ifl, geopos, dcore, serr)) == ERR)
+    if ((retflag2 = eclipse_where(tret[5], SE_SUN, NULL, ifl, geopos, dcore, serr)) == SE_ERR)
       return retflag2;
     dc[2] = *dcore;
     /* the maximum is always total, and there is either one or
@@ -1457,10 +1457,10 @@ next_try:
   for (i = 0; i < 2; i++) {
     j = i + k;
     tt = tret[j] + swe_deltat_ex(tret[j], ifl, serr);
-    if (swe_calc(tt, SE_SUN, iflag, ls, serr) == ERR)
-        return ERR;
-    if (swe_calc(tt, SE_MOON, iflag, lm, serr) == ERR)
-        return ERR;
+    if (swe_calc(tt, SE_SUN, iflag, ls, serr) == SE_ERR)
+        return SE_ERR;
+    if (swe_calc(tt, SE_MOON, iflag, lm, serr) == SE_ERR)
+        return SE_ERR;
     dc[i] = swe_degnorm(ls[0] - lm[0]);
     if (dc[i] > 180)
       dc[i] -= 360;
@@ -1478,10 +1478,10 @@ next_try:
         j++, dt /= 3) {
       for (i = 0, t = tjd; i <= 1; i++, t -= dt) {
         tt = t + swe_deltat_ex(t, ifl, serr);
-        if (swe_calc(tt, SE_SUN, iflag, ls, serr) == ERR)
-          return ERR;
-        if (swe_calc(tt, SE_MOON, iflag, lm, serr) == ERR)
-          return ERR;
+        if (swe_calc(tt, SE_SUN, iflag, ls, serr) == SE_ERR)
+          return SE_ERR;
+        if (swe_calc(tt, SE_MOON, iflag, lm, serr) == SE_ERR)
+          return SE_ERR;
         dc[i] = swe_degnorm(ls[0] - lm[0]);
         if (dc[i] > 180)
           dc[i] -= 360;
@@ -1609,14 +1609,14 @@ int32 CALL_CONV swe_lun_occult_when_glob(
   if (ifltype == (SE_ECL_PARTIAL | SE_ECL_CENTRAL)) {
     if (serr != NULL)
       strcpy(serr, "central partial eclipses do not exist");
-    return ERR;
+    return SE_ERR;
   }
   if (ipl != SE_SUN) {
     ifltype2 = (ifltype & ~(SE_ECL_NONCENTRAL | SE_ECL_CENTRAL));
     if (ifltype2 == SE_ECL_ANNULAR || ifltype == SE_ECL_ANNULAR_TOTAL) {
       if (serr != NULL)
 	sprintf(serr, "annular occulation do not exist for object %d %s\n", ipl, starname);
-      return ERR;
+      return SE_ERR;
     }
   }
   if (ipl != SE_SUN && (ifltype & (SE_ECL_ANNULAR | SE_ECL_ANNULAR_TOTAL)))
@@ -1638,28 +1638,28 @@ int32 CALL_CONV swe_lun_occult_when_glob(
   t = tjd_start;
   tjd = t;
 next_try:
-  if (calc_planet_star(t, ipl, starname, ifl, ls, serr) == ERR)
-      return ERR;
+  if (calc_planet_star(t, ipl, starname, ifl, ls, serr) == SE_ERR)
+      return SE_ERR;
   /* fixed stars with an ecliptic latitude > 7  or < -7 cannot have 
    * an occultation. Even lunar parallax andd proper motion of star
    * will never allow it. */
   if (fabs(ls[1]) > 7 && starname != NULL && *starname != '\0') {
     if (serr != NULL) 
       sprintf(serr, "occultation never occurs: star %s has ecl. lat. %.1f", starname, ls[1]);
-    return ERR;
+    return SE_ERR;
   }
-  if (swe_calc(t, SE_MOON, ifl, lm, serr) == ERR)
-      return ERR;
+  if (swe_calc(t, SE_MOON, ifl, lm, serr) == SE_ERR)
+      return SE_ERR;
   dl = swe_degnorm(ls[0] - lm[0]);
   if (direction < 0)
     dl -= 360;
   /* get rough conjunction in ecliptic longitude */
   while (fabs(dl) > 0.1) {
     t += dl / 13;
-    if (calc_planet_star(t, ipl, starname, ifl, ls, serr) == ERR)
-	return ERR;
-    if (swe_calc(t, SE_MOON, ifl, lm, serr) == ERR)
-	return ERR;
+    if (calc_planet_star(t, ipl, starname, ifl, ls, serr) == SE_ERR)
+	return SE_ERR;
+    if (swe_calc(t, SE_MOON, ifl, lm, serr) == SE_ERR)
+	return SE_ERR;
     dl = swe_degnorm(ls[0] - lm[0]);
     if (dl > 180) dl -= 360;
   }
@@ -1699,14 +1699,14 @@ next_try:
        dt > 0.0001; 
        dt /= dtdiv) {
     for (i = 0, t = tjd - dt; i <= 2; i++, t += dt) {
-      if (calc_planet_star(t, ipl, starname, iflag, ls, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_MOON, iflag, lm, serr) == ERR)
-        return ERR;
-      if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == ERR)
-        return ERR;
+      if (calc_planet_star(t, ipl, starname, iflag, ls, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_MOON, iflag, lm, serr) == SE_ERR)
+        return SE_ERR;
+      if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == SE_ERR)
+        return SE_ERR;
       dc[i] = acos(swi_dot_prod_unit(xs, xm)) * RADTODEG;
       rmoon = asin(RMOON / lm[2]) * RADTODEG;
       rsun = asin(drad / ls[2]) * RADTODEG;
@@ -1717,13 +1717,13 @@ next_try:
   }
   tjd -= swe_deltat_ex(tjd, ifl, serr);
   tjds = tjd;
-  if ((retflag = eclipse_where(tjd, ipl, starname, ifl, geopos, dcore, serr)) == ERR)
+  if ((retflag = eclipse_where(tjd, ipl, starname, ifl, geopos, dcore, serr)) == SE_ERR)
     return retflag;
   retflag2 = retflag;
     /* in extreme cases _where() returns no eclipse, where there is
      * actually a very small one, therefore call _how() with the
      * coordinates returned by _where(): */
-  /* if ((retflag2 = eclipse_how(tjd, ipl, starname, ifl, geopos[0], geopos[1], 0, attr, serr)) == ERR)
+  /* if ((retflag2 = eclipse_how(tjd, ipl, starname, ifl, geopos[0], geopos[1], 0, attr, serr)) == SE_ERR)
     return retflag2; */
   if (retflag2 == 0) {
     /* only one try! */
@@ -1750,7 +1750,7 @@ next_try:
    * eclipse type, SE_ECL_TOTAL, _ANNULAR, etc.
    * SE_ECL_ANNULAR_TOTAL will be discovered later
    */
-  if ((retflag = eclipse_where(tjd, ipl, starname, ifl, geopos, dcore, serr)) == ERR)
+  if ((retflag = eclipse_where(tjd, ipl, starname, ifl, geopos, dcore, serr)) == SE_ERR)
     return retflag;
   if (retflag == 0) {	/* can happen with extremely small percentage */
     retflag = SE_ECL_PARTIAL | SE_ECL_NONCENTRAL;
@@ -1844,7 +1844,7 @@ next_try:
       i1 = 6; i2 = 7;
     }
     for (i = 0, t = tjd - dta; i <= 2; i += 1, t += dta) {
-      if ((retflag2 = eclipse_where(t, ipl, starname, ifl, geopos, dcore, serr)) == ERR)
+      if ((retflag2 = eclipse_where(t, ipl, starname, ifl, geopos, dcore, serr)) == SE_ERR)
         return retflag2;
       if (n == 0)
         dc[i] = dcore[4] / 2 + de / dcore[5] - dcore[2];
@@ -1859,7 +1859,7 @@ next_try:
     for (m = 0, dt = dtb; m < 3; m++, dt /= 3) {
       for (j = i1; j <= i2; j += (i2 - i1)) {
         for (i = 0, t = tret[j] - dt; i < 2; i++, t += dt) {
-          if ((retflag2 = eclipse_where(t, ipl, starname, ifl, geopos, dcore, serr)) == ERR)
+          if ((retflag2 = eclipse_where(t, ipl, starname, ifl, geopos, dcore, serr)) == SE_ERR)
             return retflag2;
           if (n == 0)
             dc[i] = dcore[4] / 2 + de / dcore[5] - dcore[2];
@@ -1877,13 +1877,13 @@ next_try:
    * annular-total eclipses
    */
   if (retflag & SE_ECL_TOTAL) {
-    if ((retflag2 = eclipse_where(tret[0], ipl, starname, ifl, geopos, dcore, serr)) == ERR)
+    if ((retflag2 = eclipse_where(tret[0], ipl, starname, ifl, geopos, dcore, serr)) == SE_ERR)
       return retflag2;
     dc[0] = *dcore;
-    if ((retflag2 = eclipse_where(tret[4], ipl, starname, ifl, geopos, dcore, serr)) == ERR)
+    if ((retflag2 = eclipse_where(tret[4], ipl, starname, ifl, geopos, dcore, serr)) == SE_ERR)
       return retflag2;
     dc[1] = *dcore;
-    if ((retflag2 = eclipse_where(tret[5], ipl, starname, ifl, geopos, dcore, serr)) == ERR)
+    if ((retflag2 = eclipse_where(tret[5], ipl, starname, ifl, geopos, dcore, serr)) == SE_ERR)
       return retflag2;
     dc[2] = *dcore;
     /* the maximum is always total, and there is either one or
@@ -1926,10 +1926,10 @@ next_try:
   for (i = 0; i < 2; i++) {
     j = i + k;
     tt = tret[j] + swe_deltat_ex(tret[j], ifl, serr);
-    if (calc_planet_star(tt, ipl, starname, iflag, ls, serr) == ERR)
-        return ERR;
-    if (swe_calc(tt, SE_MOON, iflag, lm, serr) == ERR)
-        return ERR;
+    if (calc_planet_star(tt, ipl, starname, iflag, ls, serr) == SE_ERR)
+        return SE_ERR;
+    if (swe_calc(tt, SE_MOON, iflag, lm, serr) == SE_ERR)
+        return SE_ERR;
     dc[i] = swe_degnorm(ls[0] - lm[0]);
     if (dc[i] > 180)
       dc[i] -= 360;
@@ -1947,10 +1947,10 @@ next_try:
         j++, dt /= 3) {
       for (i = 0, t = tjd; i <= 1; i++, t -= dt) {
         tt = t + swe_deltat_ex(t, ifl, serr);
-        if (calc_planet_star(tt, ipl, starname, iflag, ls, serr) == ERR)
-          return ERR;
-        if (swe_calc(tt, SE_MOON, iflag, lm, serr) == ERR)
-          return ERR;
+        if (calc_planet_star(tt, ipl, starname, iflag, ls, serr) == SE_ERR)
+          return SE_ERR;
+        if (swe_calc(tt, SE_MOON, iflag, lm, serr) == SE_ERR)
+          return SE_ERR;
         dc[i] = swe_degnorm(ls[0] - lm[0]);
         if (dc[i] > 180)
           dc[i] -= 360;
@@ -2024,7 +2024,7 @@ int32 CALL_CONV swe_sol_eclipse_when_loc(double tjd_start, int32 ifl,
   if (geopos[2] < SEI_ECL_GEOALT_MIN || geopos[2] > SEI_ECL_GEOALT_MAX) {
     if (serr != NULL)
       sprintf(serr, "location for eclipses must be between %.0f and %.0f m above sea", SEI_ECL_GEOALT_MIN, SEI_ECL_GEOALT_MAX);
-    return ERR;
+    return SE_ERR;
   }
   ifl &= SEFLG_EPHMASK; 
   swi_set_tid_acc(tjd_start, ifl, 0, serr);
@@ -2033,7 +2033,7 @@ int32 CALL_CONV swe_sol_eclipse_when_loc(double tjd_start, int32 ifl,
   /* 
    * diameter of core shadow
    */
-  if ((retflag2 = eclipse_where(tret[0], SE_SUN, NULL, ifl, geopos2, dcore, serr)) == ERR)
+  if ((retflag2 = eclipse_where(tret[0], SE_SUN, NULL, ifl, geopos2, dcore, serr)) == SE_ERR)
     return retflag2;
   retflag |= (retflag2 & SE_ECL_NONCENTRAL);
   attr[3] = dcore[0];
@@ -2078,7 +2078,7 @@ int32 CALL_CONV swe_lun_occult_when_loc(double tjd_start, int32 ipl, char *starn
   if (geopos[2] < SEI_ECL_GEOALT_MIN || geopos[2] > SEI_ECL_GEOALT_MAX) {
     if (serr != NULL)
       sprintf(serr, "location for occultations must be between %.0f and %.0f m above sea", SEI_ECL_GEOALT_MIN, SEI_ECL_GEOALT_MAX);
-    return ERR;
+    return SE_ERR;
   }
   if (ipl < 0) ipl = 0;
   if (ipl == SE_AST_OFFSET + 134340)
@@ -2090,7 +2090,7 @@ int32 CALL_CONV swe_lun_occult_when_loc(double tjd_start, int32 ipl, char *starn
   /* 
    * diameter of core shadow
    */
-  if ((retflag2 = eclipse_where(tret[0], ipl, starname, ifl, geopos2, dcore, serr)) == ERR)
+  if ((retflag2 = eclipse_where(tret[0], ipl, starname, ifl, geopos2, dcore, serr)) == SE_ERR)
     return retflag2;
   retflag |= (retflag2 & SE_ECL_NONCENTRAL);
   attr[3] = dcore[0];
@@ -2174,14 +2174,14 @@ next_try:
     for (i = 0, t = tjd - dt; i <= 2; i++, t += dt) {
       /* this takes some time, but is necessary to avoid
        * missing an eclipse */
-      if (swe_calc(t, SE_SUN, iflagcart, xs, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_SUN, iflag, ls, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_MOON, iflag, lm, serr) == ERR)
-        return ERR;
+      if (swe_calc(t, SE_SUN, iflagcart, xs, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_SUN, iflag, ls, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_MOON, iflag, lm, serr) == SE_ERR)
+        return SE_ERR;
       dm = sqrt(square_sum(xm));
       ds = sqrt(square_sum(xs));
       for (k = 0; k < 3; k++) {
@@ -2193,14 +2193,14 @@ next_try:
     find_maximum(dc[0], dc[1], dc[2], dt, &dtint, &dctr);
     tjd += dtint + dt;
   }
-  if (swe_calc(tjd, SE_SUN, iflagcart, xs, serr) == ERR)
-        return ERR;
-  if (swe_calc(tjd, SE_SUN, iflag, ls, serr) == ERR)
-        return ERR;
-  if (swe_calc(tjd, SE_MOON, iflagcart, xm, serr) == ERR)
-        return ERR;
-  if (swe_calc(tjd, SE_MOON, iflag, lm, serr) == ERR)
-        return ERR;
+  if (swe_calc(tjd, SE_SUN, iflagcart, xs, serr) == SE_ERR)
+        return SE_ERR;
+  if (swe_calc(tjd, SE_SUN, iflag, ls, serr) == SE_ERR)
+        return SE_ERR;
+  if (swe_calc(tjd, SE_MOON, iflagcart, xm, serr) == SE_ERR)
+        return SE_ERR;
+  if (swe_calc(tjd, SE_MOON, iflag, lm, serr) == SE_ERR)
+        return SE_ERR;
   dctr = acos(swi_dot_prod_unit(xs, xm)) * RADTODEG;
   rmoon = asin(RMOON / lm[2]) * RADTODEG;
   rsun = asin(RSUN / ls[2]) * RADTODEG;
@@ -2236,10 +2236,10 @@ next_try:
   else {
     dc[1] = fabs(rsminusrm) - dctrmin;
     for (i = 0, t = tjd - twomin; i <= 2; i += 2, t = tjd + twomin) {
-      if (swe_calc(t, SE_SUN, iflagcart, xs, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == ERR)
-        return ERR;
+      if (swe_calc(t, SE_SUN, iflagcart, xs, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == SE_ERR)
+        return SE_ERR;
       dm = sqrt(square_sum(xm));
       ds = sqrt(square_sum(xs));
       rmoon = asin(RMOON / dm) * RADTODEG;
@@ -2258,10 +2258,10 @@ next_try:
     tret[3] = tjd + dt2 + twomin;
     for (m = 0, dt = tensec; m < 2; m++, dt /= 10) {
       for (j = 2; j <= 3; j++) {
-        if (swe_calc(tret[j], SE_SUN, iflagcart | SEFLG_SPEED, xs, serr) == ERR)
-          return ERR;
-        if (swe_calc(tret[j], SE_MOON, iflagcart | SEFLG_SPEED, xm, serr) == ERR)
-          return ERR;
+        if (swe_calc(tret[j], SE_SUN, iflagcart | SEFLG_SPEED, xs, serr) == SE_ERR)
+          return SE_ERR;
+        if (swe_calc(tret[j], SE_MOON, iflagcart | SEFLG_SPEED, xm, serr) == SE_ERR)
+          return SE_ERR;
         for (i = 0; i < 2; i++) {
           if (i == 1) {
             for(k = 0; k < 3; k++) {
@@ -2292,10 +2292,10 @@ next_try:
   /* contacts 1 and 4 */
   dc[1] = rsplusrm - dctrmin;
   for (i = 0, t = tjd - twohr; i <= 2; i += 2, t = tjd + twohr) {
-    if (swe_calc(t, SE_SUN, iflagcart, xs, serr) == ERR)
-      return ERR;
-    if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == ERR)
-      return ERR;
+    if (swe_calc(t, SE_SUN, iflagcart, xs, serr) == SE_ERR)
+      return SE_ERR;
+    if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == SE_ERR)
+      return SE_ERR;
     dm = sqrt(square_sum(xm));
     ds = sqrt(square_sum(xs));
     rmoon = asin(RMOON / dm) * RADTODEG;
@@ -2313,10 +2313,10 @@ next_try:
   tret[4] = tjd + dt2 + twohr;
   for (m = 0, dt = tenmin; m < 3; m++, dt /= 10) {
     for (j = 1; j <= 4; j += 3) {
-      if (swe_calc(tret[j], SE_SUN, iflagcart | SEFLG_SPEED, xs, serr) == ERR)
-        return ERR;
-      if (swe_calc(tret[j], SE_MOON, iflagcart | SEFLG_SPEED, xm, serr) == ERR)
-        return ERR;
+      if (swe_calc(tret[j], SE_SUN, iflagcart | SEFLG_SPEED, xs, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(tret[j], SE_MOON, iflagcart | SEFLG_SPEED, xm, serr) == SE_ERR)
+        return SE_ERR;
       for (i = 0; i < 2; i++) {
         if (i == 1) {
           for(k = 0; k < 3; k++) {
@@ -2349,8 +2349,8 @@ next_try:
     if (tret[i] == 0)
       continue;
     if (eclipse_how(tret[i], SE_SUN, NULL, ifl, geopos[0], geopos[1], geopos[2], 
-		attr, serr) == ERR)
-      return ERR;
+		attr, serr) == SE_ERR)
+      return SE_ERR;
     /*if (retflag2 & SE_ECL_VISIBLE) { could be wrong for 1st/4th contact */
     if (attr[6] > 0) {	/* this is safe, sun above horizon, using app. alt. */
       retflag |= SE_ECL_VISIBLE;
@@ -2373,12 +2373,12 @@ next_try:
     goto next_try;
   }
 #endif
-  if ((retc = swe_rise_trans(tret[1] - 0.001, SE_SUN, NULL, iflag, SE_CALC_RISE|SE_BIT_DISC_BOTTOM, geopos, 0, 0, &tjdr, serr)) == ERR)
-    return ERR;
+  if ((retc = swe_rise_trans(tret[1] - 0.001, SE_SUN, NULL, iflag, SE_CALC_RISE|SE_BIT_DISC_BOTTOM, geopos, 0, 0, &tjdr, serr)) == SE_ERR)
+    return SE_ERR;
   if (retc == -2) /* circumpolar sun */
     return retflag;
-  if ((retc = swe_rise_trans(tret[1] - 0.001, SE_SUN, NULL, iflag, SE_CALC_SET|SE_BIT_DISC_BOTTOM, geopos, 0, 0, &tjds, serr)) == ERR)
-    return ERR;
+  if ((retc = swe_rise_trans(tret[1] - 0.001, SE_SUN, NULL, iflag, SE_CALC_SET|SE_BIT_DISC_BOTTOM, geopos, 0, 0, &tjds, serr)) == SE_ERR)
+    return SE_ERR;
   if (retc == -2) /* circumpolar sun */
     return retflag;
   if (tjds < tret[1] || (tjds > tjdr && tjdr > tret[4])) {
@@ -2392,8 +2392,8 @@ next_try:
     tret[5] = tjdr;
     if (!(retflag & SE_ECL_MAX_VISIBLE)) {
       tret[0] = tjdr;
-      if ((retc = eclipse_how(tret[5], SE_SUN, NULL, ifl, geopos[0], geopos[1], geopos[2], attr, serr)) == ERR)
-	return ERR;
+      if ((retc = eclipse_how(tret[5], SE_SUN, NULL, ifl, geopos[0], geopos[1], geopos[2], attr, serr)) == SE_ERR)
+	return SE_ERR;
       retflag &= ~(SE_ECL_TOTAL|SE_ECL_ANNULAR|SE_ECL_PARTIAL);
       retflag |= (retc & (SE_ECL_TOTAL|SE_ECL_ANNULAR|SE_ECL_PARTIAL));
     }
@@ -2402,8 +2402,8 @@ next_try:
     tret[6] = tjds;
     if (!(retflag & SE_ECL_MAX_VISIBLE)) {
       tret[0] = tjds;
-      if ((retc = eclipse_how(tret[6], SE_SUN, NULL, ifl, geopos[0], geopos[1], geopos[2], attr, serr)) == ERR)
-	return ERR;
+      if ((retc = eclipse_how(tret[6], SE_SUN, NULL, ifl, geopos[0], geopos[1], geopos[2], attr, serr)) == SE_ERR)
+	return SE_ERR;
       retflag &= ~(SE_ECL_TOTAL|SE_ECL_ANNULAR|SE_ECL_PARTIAL);
       retflag |= (retc & (SE_ECL_TOTAL|SE_ECL_ANNULAR|SE_ECL_PARTIAL));
     }
@@ -2448,28 +2448,28 @@ static int32 occult_when_loc(
   tjd = tjd_start;
 next_try:
   //is_partial = FALSE;
-  if (calc_planet_star(t, ipl, starname, iflaggeo, ls, serr) == ERR)
-      return ERR;
+  if (calc_planet_star(t, ipl, starname, iflaggeo, ls, serr) == SE_ERR)
+      return SE_ERR;
   /* fixed stars with an ecliptic latitude > 7  or < -7 cannot have 
    * an occultation. Even lunar parallax andd proper motion of star
    * will never allow it. */
   if (fabs(ls[1]) > 7 && starname != NULL && *starname != '\0') {
     if (serr != NULL) 
       sprintf(serr, "occultation never occurs: star %s has ecl. lat. %.1f", starname, ls[1]);
-    return ERR;
+    return SE_ERR;
   }
-  if (swe_calc(t, SE_MOON, iflaggeo, lm, serr) == ERR)
-      return ERR;
+  if (swe_calc(t, SE_MOON, iflaggeo, lm, serr) == SE_ERR)
+      return SE_ERR;
   dl = swe_degnorm(ls[0] - lm[0]);
   if (direction < 0)
     dl -= 360;
   /* get rough conjunction in ecliptic longitude */
   while (fabs(dl) > 0.1) {
     t += dl / 13;
-    if (calc_planet_star(t, ipl, starname, iflaggeo, ls, serr) == ERR)
-	return ERR;
-    if (swe_calc(t, SE_MOON, iflaggeo, lm, serr) == ERR)
-	return ERR;
+    if (calc_planet_star(t, ipl, starname, iflaggeo, ls, serr) == SE_ERR)
+	return SE_ERR;
+    if (swe_calc(t, SE_MOON, iflaggeo, lm, serr) == SE_ERR)
+	return SE_ERR;
     dl = swe_degnorm(ls[0] - lm[0]);
     if (dl > 180) dl -= 360;
   }
@@ -2507,14 +2507,14 @@ next_try:
     for (i = 0, t = tjd - dt; i <= 2; i++, t += dt) {
       /* this takes some time, but is necessary to avoid
        * missing an eclipse */
-      if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == ERR)
-        return ERR;
-      if (calc_planet_star(t, ipl, starname, iflag, ls, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_MOON, iflag, lm, serr) == ERR)
-        return ERR;
+      if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == SE_ERR)
+        return SE_ERR;
+      if (calc_planet_star(t, ipl, starname, iflag, ls, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_MOON, iflag, lm, serr) == SE_ERR)
+        return SE_ERR;
       if (dt < 0.1 && fabs(ls[1] - lm[1]) > 2) {
         if (one_try || stop_after_this) {
           stop_after_this = TRUE;
@@ -2537,14 +2537,14 @@ next_try:
     tret[0] = tjd + direction;  /* return a date suitable for next try */
     return 0;
   }
-  if (calc_planet_star(tjd, ipl, starname, iflagcart, xs, serr) == ERR)
-        return ERR;
-  if (calc_planet_star(tjd, ipl, starname, iflag, ls, serr) == ERR)
-        return ERR;
-  if (swe_calc(tjd, SE_MOON, iflagcart, xm, serr) == ERR)
-        return ERR;
-  if (swe_calc(tjd, SE_MOON, iflag, lm, serr) == ERR)
-        return ERR;
+  if (calc_planet_star(tjd, ipl, starname, iflagcart, xs, serr) == SE_ERR)
+        return SE_ERR;
+  if (calc_planet_star(tjd, ipl, starname, iflag, ls, serr) == SE_ERR)
+        return SE_ERR;
+  if (swe_calc(tjd, SE_MOON, iflagcart, xm, serr) == SE_ERR)
+        return SE_ERR;
+  if (swe_calc(tjd, SE_MOON, iflag, lm, serr) == SE_ERR)
+        return SE_ERR;
   dctr = acos(swi_dot_prod_unit(xs, xm)) * RADTODEG;
   rmoon = asin(RMOON / lm[2]) * RADTODEG;
   rsun = asin(drad / ls[2]) * RADTODEG;
@@ -2587,10 +2587,10 @@ next_try:
   } else {
     dc[1] = fabs(rsminusrm) - dctrmin;
     for (i = 0, t = tjd - twomin; i <= 2; i += 2, t = tjd + twomin) {
-      if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == ERR)
-        return ERR;
+      if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == SE_ERR)
+        return SE_ERR;
       dm = sqrt(square_sum(xm));
       ds = sqrt(square_sum(xs));
       rmoon = asin(RMOON / dm) * RADTODEG;
@@ -2609,10 +2609,10 @@ next_try:
     tret[3] = tjd + dt2 + twomin;
     for (m = 0, dt = tensec; m < 2; m++, dt /= 10) {
       for (j = 2; j <= 3; j++) {
-        if (calc_planet_star(tret[j], ipl, starname, iflagcart | SEFLG_SPEED, xs, serr) == ERR)
-          return ERR;
-        if (swe_calc(tret[j], SE_MOON, iflagcart | SEFLG_SPEED, xm, serr) == ERR)
-          return ERR;
+        if (calc_planet_star(tret[j], ipl, starname, iflagcart | SEFLG_SPEED, xs, serr) == SE_ERR)
+          return SE_ERR;
+        if (swe_calc(tret[j], SE_MOON, iflagcart | SEFLG_SPEED, xm, serr) == SE_ERR)
+          return SE_ERR;
         for (i = 0; i < 2; i++) {
           if (i == 1) {
             for(k = 0; k < 3; k++) {
@@ -2645,10 +2645,10 @@ next_try:
   dc[1] = rsplusrm - dctrmin;
 if (starname == NULL || *starname == '\0') {
   for (i = 0, t = tjd - twohr; i <= 2; i += 2, t = tjd + twohr) {
-    if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == ERR)
-      return ERR;
-    if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == ERR)
-      return ERR;
+    if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == SE_ERR)
+      return SE_ERR;
+    if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == SE_ERR)
+      return SE_ERR;
     dm = sqrt(square_sum(xm));
     ds = sqrt(square_sum(xs));
     rmoon = asin(RMOON / dm) * RADTODEG;
@@ -2666,10 +2666,10 @@ if (starname == NULL || *starname == '\0') {
   tret[4] = tjd + dt2 + twohr;
   for (m = 0, dt = tenmin; m < 3; m++, dt /= 10) {
     for (j = 1; j <= 4; j += 3) {
-      if (calc_planet_star(tret[j], ipl, starname, iflagcart | SEFLG_SPEED, xs, serr) == ERR)
-        return ERR;
-      if (swe_calc(tret[j], SE_MOON, iflagcart | SEFLG_SPEED, xm, serr) == ERR)
-        return ERR;
+      if (calc_planet_star(tret[j], ipl, starname, iflagcart | SEFLG_SPEED, xs, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(tret[j], SE_MOON, iflagcart | SEFLG_SPEED, xm, serr) == SE_ERR)
+        return SE_ERR;
       for (i = 0; i < 2; i++) {
         if (i == 1) {
           for(k = 0; k < 3; k++) {
@@ -2706,8 +2706,8 @@ if (starname == NULL || *starname == '\0') {
     if (tret[i] == 0)
       continue;
     if (eclipse_how(tret[i], ipl, starname, ifl, geopos[0], geopos[1], geopos[2], 
-		attr, serr) == ERR)
-      return ERR;
+		attr, serr) == SE_ERR)
+      return SE_ERR;
     /*if (retflag2 & SE_ECL_VISIBLE) { could be wrong for 1st/4th contact */
     if (attr[6] > 0) {	/* this is save, sun above horizon (using app. alt.) */
       retflag |= SE_ECL_VISIBLE;
@@ -2733,10 +2733,10 @@ if (starname == NULL || *starname == '\0') {
     goto next_try;
   }
 #endif
-  if ((retc = swe_rise_trans(tret[1] - 0.1, ipl, starname, iflag, SE_CALC_RISE|SE_BIT_DISC_BOTTOM, geopos, 0, 0, &tjdr, serr)) == ERR)
-    return ERR;
-  if (retc >= 0 && (retc = swe_rise_trans(tret[1] - 0.1, ipl, starname, iflag, SE_CALC_SET|SE_BIT_DISC_BOTTOM, geopos, 0, 0, &tjds, serr)) == ERR)
-    return ERR;
+  if ((retc = swe_rise_trans(tret[1] - 0.1, ipl, starname, iflag, SE_CALC_RISE|SE_BIT_DISC_BOTTOM, geopos, 0, 0, &tjdr, serr)) == SE_ERR)
+    return SE_ERR;
+  if (retc >= 0 && (retc = swe_rise_trans(tret[1] - 0.1, ipl, starname, iflag, SE_CALC_SET|SE_BIT_DISC_BOTTOM, geopos, 0, 0, &tjds, serr)) == SE_ERR)
+    return SE_ERR;
   if (retc >= 0) {
     if (tjdr > tret[1] && tjdr < tret[4])
       tret[5] = tjdr;
@@ -2745,18 +2745,18 @@ if (starname == NULL || *starname == '\0') {
   }
   /* note, circumpolar sun above horizon is not tested */ 
   //if (!is_partial) {
-    if ((retc = swe_rise_trans(tret[1], SE_SUN, NULL, iflag, SE_CALC_RISE, geopos, 0, 0, &tjdr, serr)) == ERR)
-      return ERR;
-    if (retc >= 0 && (retc = swe_rise_trans(tret[1], SE_SUN, NULL, iflag, SE_CALC_SET, geopos, 0, 0, &tjds, serr)) == ERR)
-      return ERR;
+    if ((retc = swe_rise_trans(tret[1], SE_SUN, NULL, iflag, SE_CALC_RISE, geopos, 0, 0, &tjdr, serr)) == SE_ERR)
+      return SE_ERR;
+    if (retc >= 0 && (retc = swe_rise_trans(tret[1], SE_SUN, NULL, iflag, SE_CALC_SET, geopos, 0, 0, &tjds, serr)) == SE_ERR)
+      return SE_ERR;
     if (retc >= 0) {
       if (tjds < tjdr)
 	retflag |= SE_ECL_OCC_BEG_DAYLIGHT;
     } 
-    if ((retc = swe_rise_trans(tret[4], SE_SUN, NULL, iflag, SE_CALC_RISE, geopos, 0, 0, &tjdr, serr)) == ERR)
-      return ERR;
-    if (retc >= 0 && (retc = swe_rise_trans(tret[4], SE_SUN, NULL, iflag, SE_CALC_SET, geopos, 0, 0, &tjds, serr)) == ERR)
-      return ERR;
+    if ((retc = swe_rise_trans(tret[4], SE_SUN, NULL, iflag, SE_CALC_RISE, geopos, 0, 0, &tjdr, serr)) == SE_ERR)
+      return SE_ERR;
+    if (retc >= 0 && (retc = swe_rise_trans(tret[4], SE_SUN, NULL, iflag, SE_CALC_SET, geopos, 0, 0, &tjds, serr)) == SE_ERR)
+      return SE_ERR;
     if (retc >= 0) {
       if (tjds < tjdr)
 	retflag |= SE_ECL_OCC_END_DAYLIGHT;
@@ -3205,7 +3205,7 @@ int32 CALL_CONV swe_lun_eclipse_how(
   if (geopos != NULL && (geopos[2] < SEI_ECL_GEOALT_MIN || geopos[2] > SEI_ECL_GEOALT_MAX)) {
     if (serr != NULL)
       sprintf(serr, "location for eclipses must be between %.0f and %.0f m above sea", SEI_ECL_GEOALT_MIN, SEI_ECL_GEOALT_MAX);
-    return ERR;
+    return SE_ERR;
   }
   ifl = ifl & ~SEFLG_TOPOCTR;
   ifl &= ~(SEFLG_JPLHOR | SEFLG_JPLHOR_APPROX);
@@ -3218,8 +3218,8 @@ int32 CALL_CONV swe_lun_eclipse_how(
    * azimuth and altitude of moon
    */
   swe_set_topo(geopos[0], geopos[1], geopos[2]);
-  if (swe_calc_ut(tjd_ut, SE_MOON, ifl | SEFLG_TOPOCTR | SEFLG_EQUATORIAL, lm, serr) == ERR)
-    return ERR;
+  if (swe_calc_ut(tjd_ut, SE_MOON, ifl | SEFLG_TOPOCTR | SEFLG_EQUATORIAL, lm, serr) == SE_ERR)
+    return SE_ERR;
   swe_azalt(tjd_ut, SE_EQU2HOR, geopos, 0, 10, lm, xaz);
   attr[4] = xaz[0];
   attr[5] = xaz[1];
@@ -3265,13 +3265,13 @@ static int32 lun_eclipse_how(
   deltat = swe_deltat_ex(tjd_ut, ifl, serr);
   tjd = tjd_ut + deltat;
   /* moon in cartesian coordinates */
-  if (swe_calc(tjd, SE_MOON, iflag, rm, serr) == ERR)
-    return ERR;
+  if (swe_calc(tjd, SE_MOON, iflag, rm, serr) == SE_ERR)
+    return SE_ERR;
   /* distance of moon from geocenter */
   dm = sqrt(square_sum(rm));
   /* sun in cartesian coordinates */
-  if (swe_calc(tjd, SE_SUN, iflag, rs, serr) == ERR)
-    return ERR;
+  if (swe_calc(tjd, SE_SUN, iflag, rs, serr) == SE_ERR)
+    return SE_ERR;
   /* distance of sun from geocenter */
   ds = sqrt(square_sum(rs));
   for (i = 0; i < 3; i++) {
@@ -3409,7 +3409,7 @@ int32 CALL_CONV swe_lun_eclipse_when(double tjd_start, int32 ifl, int32 ifltype,
       if (serr != NULL) {
         strcpy(serr, "annular lunar eclipses don't exist");
       }
-      return ERR; /* avoids infinite loop */
+      return SE_ERR; /* avoids infinite loop */
     }
   }
   if (ifltype == 0)
@@ -3491,10 +3491,10 @@ next_try:
        dt > 0.001; 
        j++, dt /= dtdiv) {
     for (i = 0, t = tjd - dt; i <= 2; i++, t += dt) {
-      if (swe_calc(t, SE_SUN, iflagcart, xs, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == ERR)
-        return ERR;
+      if (swe_calc(t, SE_SUN, iflagcart, xs, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == SE_ERR)
+        return SE_ERR;
       for (m = 0; m < 3; m++) {
         xs[m] -= xm[m];	/* selenocentric sun */
         xm[m] = -xm[m];	/* selenocentric earth */
@@ -3516,7 +3516,7 @@ next_try:
   tjd2 = tjd - swe_deltat_ex(tjd, ifl, serr);
   tjd2 = tjd - swe_deltat_ex(tjd2, ifl, serr);
   tjd = tjd - swe_deltat_ex(tjd2, ifl, serr);
-  if ((retflag = swe_lun_eclipse_how(tjd, ifl, NULL, attr, serr)) == ERR)
+  if ((retflag = swe_lun_eclipse_how(tjd, ifl, NULL, attr, serr)) == SE_ERR)
     return retflag;
   if (retflag == 0) {
     K += direction;
@@ -3569,7 +3569,7 @@ next_try:
     }
 #if 1
     for (i = 0, t = tjd - dta; i <= 2; i += 1, t += dta) {
-      if ((retflag2 = lun_eclipse_how(t, ifl, attr, dcore, serr)) == ERR)
+      if ((retflag2 = lun_eclipse_how(t, ifl, attr, dcore, serr)) == SE_ERR)
         return retflag2;
       if (n == 0)
         dc[i] = dcore[2] / 2 + RMOON / dcore[4] - dcore[0];
@@ -3589,7 +3589,7 @@ next_try:
     for (m = 0, dt = dtb / 2; m < 3; m++, dt /= 2) {
       for (j = i1; j <= i2; j += (i2 - i1)) {
         for (i = 0, t = tret[j] - dt; i < 2; i++, t += dt) {
-          if ((retflag2 = lun_eclipse_how(t, ifl, attr, dcore, serr)) == ERR)
+          if ((retflag2 = lun_eclipse_how(t, ifl, attr, dcore, serr)) == SE_ERR)
             return retflag2;
           if (n == 0)
             dc[i] = dcore[2] / 2 + RMOON / dcore[4] - dcore[0];
@@ -3641,12 +3641,12 @@ int32 CALL_CONV swe_lun_eclipse_when_loc(double tjd_start, int32 ifl,
   if (geopos != NULL && (geopos[2] < SEI_ECL_GEOALT_MIN || geopos[2] > SEI_ECL_GEOALT_MAX)) {
     if (serr != NULL)
       sprintf(serr, "location for eclipses must be between %.0f and %.0f m above sea", SEI_ECL_GEOALT_MIN, SEI_ECL_GEOALT_MAX);
-    return ERR;
+    return SE_ERR;
   }
   ifl &= ~(SEFLG_JPLHOR | SEFLG_JPLHOR_APPROX);
 next_lun_ecl:
-  if ((retflag = swe_lun_eclipse_when(tjd_start, ifl, 0, tret, backward, serr)) == ERR) {
-    return ERR;
+  if ((retflag = swe_lun_eclipse_when(tjd_start, ifl, 0, tret, backward, serr)) == SE_ERR) {
+    return SE_ERR;
   }
   /*  
    * visibility of eclipse phases 
@@ -3655,8 +3655,8 @@ next_lun_ecl:
   for (i = 7; i >= 0; i--) {
     if (i == 1) continue;
     if (tret[i] == 0) continue;
-    if ((retflag2 = swe_lun_eclipse_how(tret[i], ifl, geopos, attr, serr)) == ERR)
-      return ERR;
+    if ((retflag2 = swe_lun_eclipse_how(tret[i], ifl, geopos, attr, serr)) == SE_ERR)
+      return SE_ERR;
     if (attr[6] > 0) {  /* moon above horizon, using app. alt. */
       retflag |= SE_ECL_VISIBLE;
       switch(i) {
@@ -3680,10 +3680,10 @@ next_lun_ecl:
   }
   /* moon rise and moon set */
   tjd_max = tret[0];
-  if ((retc = swe_rise_trans(tret[6] - 0.001, SE_MOON, NULL, ifl, SE_CALC_RISE|SE_BIT_DISC_BOTTOM, geopos, 0, 0, &tjdr, serr)) == ERR)
-    return ERR;
-  if (retc >= 0 && (retc = swe_rise_trans(tret[6] - 0.001, SE_MOON, NULL, ifl, SE_CALC_SET|SE_BIT_DISC_BOTTOM, geopos, 0, 0, &tjds, serr)) == ERR)
-    return ERR;
+  if ((retc = swe_rise_trans(tret[6] - 0.001, SE_MOON, NULL, ifl, SE_CALC_RISE|SE_BIT_DISC_BOTTOM, geopos, 0, 0, &tjdr, serr)) == SE_ERR)
+    return SE_ERR;
+  if (retc >= 0 && (retc = swe_rise_trans(tret[6] - 0.001, SE_MOON, NULL, ifl, SE_CALC_SET|SE_BIT_DISC_BOTTOM, geopos, 0, 0, &tjds, serr)) == SE_ERR)
+    return SE_ERR;
   if (retc >= 0) {
     if (tjds < tret[6] || (tjds > tjdr && tjdr > tret[7])) {
       if (backward)
@@ -3716,8 +3716,8 @@ next_lun_ecl:
     }
   }
   tret[0] = tjd_max;
-  if ((retflag2 = swe_lun_eclipse_how(tjd_max, ifl, geopos, attr, serr)) == ERR)
-    return ERR;
+  if ((retflag2 = swe_lun_eclipse_how(tjd_max, ifl, geopos, attr, serr)) == SE_ERR)
+    return SE_ERR;
   if (retflag2 == 0) {
     if (backward)
       tjd_start = tret[0] - 25;
@@ -3815,21 +3815,21 @@ int32 CALL_CONV swe_pheno(double tjd, int32 ipl, int32 iflag, double *attr, char
                    SEFLG_J2000 | 
                    SEFLG_NONUT |
                    SEFLG_NOGDEFL |
-                   SEFLG_NOABERR |
+                   SEFLG_NOABSE_ERR |
                    SEFLG_TOPOCTR);
   iflagp = iflag & (SEFLG_EPHMASK | 
                    SEFLG_TRUEPOS | 
                    SEFLG_J2000 | 
                    SEFLG_NONUT |
-                   SEFLG_NOABERR);
+                   SEFLG_NOABSE_ERR);
   iflagp |= SEFLG_HELCTR;                
   epheflag = iflag & SEFLG_EPHMASK;
   /*  
    * geocentric planet
    */
-  if ((retflag = swe_calc(tjd, (int) ipl, iflag | SEFLG_XYZ, xx, serr)) == ERR)
+  if ((retflag = swe_calc(tjd, (int) ipl, iflag | SEFLG_XYZ, xx, serr)) == SE_ERR)
     /* int cast can be removed when swe_calc() gets int32 ipl definition */
-    return ERR;
+    return SE_ERR;
   // check epheflag and adjust iflag
   epheflag2 = retflag & SEFLG_EPHMASK;
   if (epheflag != epheflag2) {
@@ -3839,13 +3839,13 @@ int32 CALL_CONV swe_pheno(double tjd, int32 ipl, int32 iflag, double *attr, char
     iflagp |= epheflag2;
     epheflag = epheflag2;
   }
-  if (swe_calc(tjd, (int) ipl, iflag, lbr, serr) == ERR)
+  if (swe_calc(tjd, (int) ipl, iflag, lbr, serr) == SE_ERR)
     /* int cast can be removed when swe_calc() gets int32 ipl definition */
-    return ERR;
+    return SE_ERR;
   /* if moon, we need sun as well, for magnitude */
   if (ipl == SE_MOON) {
-    if (swe_calc(tjd, SE_SUN, iflag | SEFLG_XYZ, xxs, serr) == ERR)
-      return ERR;
+    if (swe_calc(tjd, SE_SUN, iflag | SEFLG_XYZ, xxs, serr) == SE_ERR)
+      return SE_ERR;
   }
   if (ipl != SE_SUN && ipl != SE_EARTH &&
     ipl != SE_MEAN_NODE && ipl != SE_TRUE_NODE &&
@@ -3859,12 +3859,12 @@ int32 CALL_CONV swe_pheno(double tjd, int32 ipl, int32 iflag, double *attr, char
     /* 
      * heliocentric planet at tjd - dt
      */
-    if (swe_calc(tjd - dt, (int) ipl, iflagp | SEFLG_XYZ, xx2, serr) == ERR)
+    if (swe_calc(tjd - dt, (int) ipl, iflagp | SEFLG_XYZ, xx2, serr) == SE_ERR)
     /* int cast can be removed when swe_calc() gets int32 ipl definition */
-      return ERR;
-    if (swe_calc(tjd - dt, (int) ipl, iflagp, lbr2, serr) == ERR)
+      return SE_ERR;
+    if (swe_calc(tjd - dt, (int) ipl, iflagp, lbr2, serr) == SE_ERR)
     /* int cast can be removed when swe_calc() gets int32 ipl definition */
-      return ERR;
+      return SE_ERR;
     /*
      * phase angle
      */
@@ -4076,10 +4076,10 @@ int32 CALL_CONV swe_pheno(double tjd, int32 ipl, int32 iflag, double *attr, char
     /* 
      * elongation of planet
      */
-    if (swe_calc(tjd, SE_SUN, iflag | SEFLG_XYZ, xx2, serr) == ERR)
-      return ERR;
-    if (swe_calc(tjd, SE_SUN, iflag, lbr2, serr) == ERR)
-      return ERR;
+    if (swe_calc(tjd, SE_SUN, iflag | SEFLG_XYZ, xx2, serr) == SE_ERR)
+      return SE_ERR;
+    if (swe_calc(tjd, SE_SUN, iflag, lbr2, serr) == SE_ERR)
+      return SE_ERR;
     attr[2] = acos(swi_dot_prod_unit(xx, xx2)) * RADTODEG;
   }
   /* horizontal parallax */
@@ -4087,17 +4087,17 @@ int32 CALL_CONV swe_pheno(double tjd, int32 ipl, int32 iflag, double *attr, char
     double sinhp, xm[6];
     /* geocentric horizontal parallax */
     /* Expl.Suppl. to the AA 1984, p.400 */
-    if (swe_calc(tjd, (int) ipl, epheflag|SEFLG_TRUEPOS|SEFLG_EQUATORIAL|SEFLG_RADIANS, xm, serr) == ERR)
+    if (swe_calc(tjd, (int) ipl, epheflag|SEFLG_TRUEPOS|SEFLG_EQUATORIAL|SEFLG_RADIANS, xm, serr) == SE_ERR)
       /* int cast can be removed when swe_calc() gets int32 ipl definition */
-      return ERR;
+      return SE_ERR;
     sinhp = EARTH_RADIUS / xm[2] / AUNIT;
     attr[5] = asin(sinhp) / DEGTORAD;
     /* topocentric horizontal parallax */
     if (iflag & SEFLG_TOPOCTR) {
-      if (swe_calc(tjd, (int) ipl, epheflag|SEFLG_XYZ|SEFLG_TOPOCTR, xm, serr) == ERR)
-	return ERR;
-      if (swe_calc(tjd, (int) ipl, epheflag|SEFLG_XYZ, xx, serr) == ERR)
-	return ERR;
+      if (swe_calc(tjd, (int) ipl, epheflag|SEFLG_XYZ|SEFLG_TOPOCTR, xm, serr) == SE_ERR)
+	return SE_ERR;
+      if (swe_calc(tjd, (int) ipl, epheflag|SEFLG_XYZ, xx, serr) == SE_ERR)
+	return SE_ERR;
       attr[5] = acos(swi_dot_prod_unit(xm, xx)) / DEGTORAD;
 #if 0
       {
@@ -4170,7 +4170,7 @@ static int find_zero(double y00, double y11, double y2, double dx,
   b = (y2 - y00) / 2.0;
   a = (y2 + y00) / 2.0 - c;
   if (b * b - 4 * a * c < 0) 
-    return ERR;
+    return SE_ERR;
   x1 = (-b + sqrt(b * b - 4 * a * c)) / 2 / a;
   x2 = (-b - sqrt(b * b - 4 * a * c)) / 2 / a;
   *dxret = (x1 - 1) * dx;
@@ -4248,8 +4248,8 @@ static int32 rise_set_fast(
     swe_set_topo(dgeo[0], dgeo[1], dgeo[2]);
   }
 run_rise_again:
-  if (swe_calc_ut(tjd_ut, ipl, iflagtopo, xx, serr) == ERR) 
-    return ERR;
+  if (swe_calc_ut(tjd_ut, ipl, iflagtopo, xx, serr) == SE_ERR) 
+    return SE_ERR;
   /* the diurnal arc is a bit fuzzy, 
    * - because the object changes declination during the day
    * - because there is refraction of light
@@ -4312,8 +4312,8 @@ run_rise_again:
     swe_set_topo(dgeo[0], dgeo[1], dgeo[2]);
   }
   for (i = 0; i < nloop; i++) {
-    if (swe_calc_ut(tr, ipl, iflagtopo, xx, serr) == ERR)
-      return ERR;
+    if (swe_calc_ut(tr, ipl, iflagtopo, xx, serr) == SE_ERR)
+      return SE_ERR;
     if (rsmi & SE_BIT_GEOCTR_NO_ECL_LAT)
       xx[1] = 0;
     rdi = get_sun_rad_plus_refr(ipl, xx[2], rsmi, refr); 
@@ -4424,7 +4424,7 @@ int ncalc = 0;
   if (geopos[2] < SEI_ECL_GEOALT_MIN || geopos[2] > SEI_ECL_GEOALT_MAX) {
     if (serr != NULL)
       sprintf(serr, "location for swe_rise_trans() must be between %.0f and %.0f m above sea", SEI_ECL_GEOALT_MIN, SEI_ECL_GEOALT_MAX);
-    return ERR;
+    return SE_ERR;
   }
   /*swi_set_tid_acc(tjd_ut, epheflag, 0, serr);*/
   /* function calls for Pluto with asteroid number 134340
@@ -4464,15 +4464,15 @@ int ncalc = 0;
    * western half of the sky for a short time. 
    */
   if (do_fixstar) {
-    if (swe_fixstar(starname, tjd_et, iflag, xc, serr) == ERR)
-      return ERR;
+    if (swe_fixstar(starname, tjd_et, iflag, xc, serr) == SE_ERR)
+      return SE_ERR;
   } 
   for (ii = 0, t = tjd_ut - twohrs; ii <= jmax; ii++, t += twohrs) {
     tc[ii] = t;
     if (!do_fixstar) {
       te = t + swe_deltat_ex(t, epheflag, serr);
-      if (swe_calc(te, ipl, iflag, xc, serr) == ERR)
-        return ERR;
+      if (swe_calc(te, ipl, iflag, xc, serr) == SE_ERR)
+        return SE_ERR;
 ncalc++;
     }
     if (rsmi & SE_BIT_GEOCTR_NO_ECL_LAT)
@@ -4543,8 +4543,8 @@ nazalt++;
         for (i = 0, tt = tcu - dt; i < 3; tt += dt, i++) {
           te = tt + swe_deltat_ex(tt, epheflag, serr);
           if (!do_fixstar)
-            if (swe_calc(te, ipl, iflag, xc, serr) == ERR)
-              return ERR;
+            if (swe_calc(te, ipl, iflag, xc, serr) == SE_ERR)
+              return SE_ERR;
 	    if (rsmi & SE_BIT_GEOCTR_NO_ECL_LAT)
 	      xc[1] = 0;
 ncalc++;
@@ -4574,8 +4574,8 @@ nazalt++;
         tc[j] = tculm[i];
         if (!do_fixstar) {
           te = tc[j] + swe_deltat_ex(tc[j], epheflag, serr);
-          if (swe_calc(te, ipl, iflag, xc, serr) == ERR)
-            return ERR;
+          if (swe_calc(te, ipl, iflag, xc, serr) == SE_ERR)
+            return SE_ERR;
 	  if (rsmi & SE_BIT_GEOCTR_NO_ECL_LAT)
 	    xc[1] = 0;
 ncalc++;
@@ -4636,8 +4636,8 @@ nazalt++;
       t = (t2[0] + t2[1]) / 2;
       if (!do_fixstar) {
         te = t + swe_deltat_ex(t, epheflag, serr);
-        if (swe_calc(te, ipl, iflag, xc, serr) == ERR)
-          return ERR;
+        if (swe_calc(te, ipl, iflag, xc, serr) == SE_ERR)
+          return SE_ERR;
 	if (rsmi & SE_BIT_GEOCTR_NO_ECL_LAT)
 	  xc[1] = 0;
 ncalc++;
@@ -4718,11 +4718,11 @@ static int32 calc_mer_trans(
     armc0 += 24;
   armc0 *= 15;
   if (do_fixstar) {
-    if (swe_fixstar(starname, tjd_et, iflag, x0, serr) == ERR)
-      return ERR;
+    if (swe_fixstar(starname, tjd_et, iflag, x0, serr) == SE_ERR)
+      return SE_ERR;
   } else {
-    if (swe_calc(tjd_et, ipl, iflag, x0, serr) == ERR)
-      return ERR;
+    if (swe_calc(tjd_et, ipl, iflag, x0, serr) == SE_ERR)
+      return SE_ERR;
   }
   /*
    * meridian transits
@@ -4749,8 +4749,8 @@ static int32 calc_mer_trans(
       arxc = swe_degnorm(arxc + 180);
     if (!do_fixstar) {
       te = t + swe_deltat_ex(t, epheflag, serr);
-      if (swe_calc(te, ipl, iflag, x, serr) == ERR)
-	return ERR;
+      if (swe_calc(te, ipl, iflag, x, serr) == SE_ERR)
+	return SE_ERR;
     }
   }
   *tret = t;
@@ -5104,7 +5104,7 @@ int32 CALL_CONV swe_nod_aps(double tjd_et, int32 ipl, int32 iflag,
   double uu, ny, ny2, c2, v2, pp, ro, ro2, rn, rn2;
   struct epsilon *oe;
   AS_BOOL is_true_nodaps = FALSE;
-  AS_BOOL do_aberr = !(iflag & (SEFLG_TRUEPOS | SEFLG_NOABERR));
+  AS_BOOL do_aberr = !(iflag & (SEFLG_TRUEPOS | SEFLG_NOABSE_ERR));
   AS_BOOL do_defl = !(iflag & SEFLG_TRUEPOS) && !(iflag & SEFLG_NOGDEFL);
   AS_BOOL do_focal_point = method & SE_NODBIT_FOPOINT;
   AS_BOOL ellipse_is_bary = FALSE;
@@ -5153,7 +5153,7 @@ int32 CALL_CONV swe_nod_aps(double tjd_et, int32 ipl, int32 iflag,
     if (xperi != NULL)
       for (i = 0; i <= 5; i++)
 	xperi[i] = 0;
-    return ERR;
+    return SE_ERR;
   }
   for (i = 0; i < 24; i++)
     xx[i] = 0;
@@ -5247,8 +5247,8 @@ int32 CALL_CONV swe_nod_aps(double tjd_et, int32 ipl, int32 iflag,
    ***************************************/
   } else {
     /* first, we need a heliocentric distance of the planet */
-    if (swe_calc(tjd_et, ipli, iflg0, x, serr) == ERR)
-      return ERR;
+    if (swe_calc(tjd_et, ipli, iflg0, x, serr) == SE_ERR)
+      return SE_ERR;
     iflJ2000 = (iflag & SEFLG_EPHMASK)|SEFLG_J2000|SEFLG_EQUATORIAL|SEFLG_XYZ|SEFLG_TRUEPOS|SEFLG_NONUT|SEFLG_SPEED;
     ellipse_is_bary = FALSE;
     if (ipli != SE_MOON) {
@@ -5285,12 +5285,12 @@ int32 CALL_CONV swe_nod_aps(double tjd_et, int32 ipl, int32 iflag,
     for (i = istart, t = tjd_et - dt; i <= iend; i++, t += dt) {
       if (istart == iend)
         t = tjd_et;
-      if (swe_calc(t, ipli, iflJ2000, xpos[i], serr) == ERR)
-        return ERR;
+      if (swe_calc(t, ipli, iflJ2000, xpos[i], serr) == SE_ERR)
+        return SE_ERR;
       /* the EMB is used instead of the earth */
       if (ipli == SE_EARTH) {
-        if (swe_calc(t, SE_MOON, iflJ2000 & ~(SEFLG_BARYCTR|SEFLG_HELCTR), xposm, serr) == ERR)
-          return ERR;
+        if (swe_calc(t, SE_MOON, iflJ2000 & ~(SEFLG_BARYCTR|SEFLG_HELCTR), xposm, serr) == SE_ERR)
+          return SE_ERR;
         for (j = 0; j <= 5; j++)
           xpos[i][j] += xposm[j] / (EARTH_MOON_MRAT + 1.0);
       }
@@ -5402,11 +5402,11 @@ int32 CALL_CONV swe_nod_aps(double tjd_et, int32 ipl, int32 iflag,
    * we compute the planet */
   if (ipli == SE_MOON && (iflag & (SEFLG_HELCTR | SEFLG_BARYCTR))) {
     swi_force_app_pos_etc();
-    if (swe_calc(tjd_et, SE_SUN, iflg0, x, serr) == ERR)
-      return ERR;
+    if (swe_calc(tjd_et, SE_SUN, iflg0, x, serr) == SE_ERR)
+      return SE_ERR;
   } else {
-    if (swe_calc(tjd_et, ipli, iflg0 | (iflag & SEFLG_TOPOCTR), x, serr) == ERR)
-      return ERR;
+    if (swe_calc(tjd_et, ipli, iflg0 | (iflag & SEFLG_TOPOCTR), x, serr) == SE_ERR)
+      return SE_ERR;
   }
   /***********************
    * position of observer
@@ -5414,7 +5414,7 @@ int32 CALL_CONV swe_nod_aps(double tjd_et, int32 ipl, int32 iflag,
   if (iflag & SEFLG_TOPOCTR) {
     /* geocentric position of observer */
     if (swi_get_observer(tjd_et, iflag, FALSE, xobs, serr) != OK)
-      return ERR;
+      return SE_ERR;
     /*for (i = 0; i <= 5; i++)
       xobs[i] = swed.topd.xobs[i];*/
   } else {
@@ -5510,12 +5510,12 @@ int32 CALL_CONV swe_nod_aps(double tjd_et, int32 ipl, int32 iflag,
        */
       if (iflag & SEFLG_SPEED) {
         /* get barycentric sun and earth for t-dt into save area */
-        if (swe_calc(tjd_et - dt, ipli, iflg0 | (iflag & SEFLG_TOPOCTR), x2, serr) == ERR)
-          return ERR;
+        if (swe_calc(tjd_et - dt, ipli, iflg0 | (iflag & SEFLG_TOPOCTR), x2, serr) == SE_ERR)
+          return SE_ERR;
         if (iflag & SEFLG_TOPOCTR) {
           /* geocentric position of observer */
           /* if (swi_get_observer(tjd_et - dt, iflag, FALSE, xobs, serr) != OK)
-            return ERR;*/
+            return SE_ERR;*/
           for (i = 0; i <= 5; i++)
             xobs2[i] = swed.topd.xobs[i];
         } else {
@@ -5541,8 +5541,8 @@ int32 CALL_CONV swe_nod_aps(double tjd_et, int32 ipl, int32 iflag,
          * (i.e. bary sun, earth nutation matrix!). 
          * to restore it:
          */
-        if (swe_calc(tjd_et, SE_SUN, iflg0 | (iflag & SEFLG_TOPOCTR), x2, serr) == ERR)
-          return ERR;
+        if (swe_calc(tjd_et, SE_SUN, iflg0 | (iflag & SEFLG_TOPOCTR), x2, serr) == SE_ERR)
+          return SE_ERR;
       }
     }
     /*********************
@@ -5587,16 +5587,16 @@ int32 CALL_CONV swe_nod_aps(double tjd_et, int32 ipl, int32 iflag,
       /* project onto ecliptic t0 */
       if (swed.sidd.sid_mode & SE_SIDBIT_ECL_T0) {
         if (swi_trop_ra2sid_lon(x2000, pldat.xreturn+6, pldat.xreturn+18, iflag) != OK)
-          return ERR;
+          return SE_ERR;
       /* project onto solar system equator */
       } else if (swed.sidd.sid_mode & SE_SIDBIT_SSY_PLANE) {
         if (swi_trop_ra2sid_lon_sosy(x2000, pldat.xreturn+6, iflag) != OK)
-          return ERR;
+          return SE_ERR;
       } else {
       /* traditional algorithm */
         swi_cartpol_sp(pldat.xreturn+6, pldat.xreturn); 
-	if (swi_get_ayanamsa_ex(tjd_et, iflag, &daya, serr) == ERR)
-	  return ERR;
+	if (swi_get_ayanamsa_ex(tjd_et, iflag, &daya, serr) == SE_ERR)
+	  return SE_ERR;
         pldat.xreturn[0] -= daya * DEGTORAD;
         swi_polcart_sp(pldat.xreturn, pldat.xreturn+6); 
       }
@@ -5723,13 +5723,13 @@ static int32 get_gmsm(double tjd_et, int32 ipl, int32 iflag, double r, double *g
       plm = 0;
       if (iflag & SEFLG_ORBEL_AA) {
 	for (j = SE_MERCURY; j <= SE_PLUTO; j++) {
-	  if (swe_calc(tjd_et, j, iflJ2000p, x, serr) == ERR)
-	    return ERR;
+	  if (swe_calc(tjd_et, j, iflJ2000p, x, serr) == SE_ERR)
+	    return SE_ERR;
 	  if (r > x[2])
 	    plm += 1.0 / plmass[ipl_to_elem[j]];
 	}
-	if (swe_calc(tjd_et, SE_EARTH, iflJ2000p, x, serr) == ERR)
-	  return ERR;
+	if (swe_calc(tjd_et, SE_EARTH, iflJ2000p, x, serr) == SE_ERR)
+	  return SE_ERR;
 	if (r > x[2])
 	  plm += 1.0 / plmass[ipl_to_elem[SE_EARTH]];
       }
@@ -5802,13 +5802,13 @@ int32 CALL_CONV swe_get_orbital_elements(
   if (ipl <= 0 || ipl == SE_MEAN_NODE || ipl == SE_TRUE_NODE || ipl == SE_MEAN_APOG || ipl == SE_OSCU_APOG || ipl == SE_INTP_APOG || ipl == SE_INTP_PERG) {
     if (serr != NULL)
       sprintf(serr, "error in swe_get_orbital_elements(): object %d not valid\n", ipl);
-    return ERR;
+    return SE_ERR;
   }
   if (ipl != SE_MOON)
     iflg0 |= SEFLG_HELCTR;
   /* first, we need a heliocentric distance of the planet */
-  if (swe_calc(tjd_et, ipl, iflJ2000p, x, serr) == ERR)
-    return ERR;
+  if (swe_calc(tjd_et, ipl, iflJ2000p, x, serr) == SE_ERR)
+    return SE_ERR;
   r =  x[2];
   if (ipl != SE_MOON) {
     if ((iflag & SEFLG_BARYCTR) && r > 6) {
@@ -5818,13 +5818,13 @@ int32 CALL_CONV swe_get_orbital_elements(
     }
   }
   if (get_gmsm(tjd_et, ipl, iflag, r, &Gmsm, serr))
-    return ERR;
-  if (swe_calc(tjd_et, ipl, iflJ2000, xpos, serr) == ERR)
-    return ERR;
+    return SE_ERR;
+  if (swe_calc(tjd_et, ipl, iflJ2000, xpos, serr) == SE_ERR)
+    return SE_ERR;
   /* the EMB is used instead of the earth */
   if (ipl == SE_EARTH) {
-    if (swe_calc(tjd_et, SE_MOON, iflJ2000 & ~(SEFLG_BARYCTR|SEFLG_HELCTR), xposm, serr) == ERR)
-      return ERR;
+    if (swe_calc(tjd_et, SE_MOON, iflJ2000 & ~(SEFLG_BARYCTR|SEFLG_HELCTR), xposm, serr) == SE_ERR)
+      return SE_ERR;
     for (j = 0; j <= 5; j++)
       xpos[j] += xposm[j] / (EARTH_MOON_MRAT + 1.0);
   }
@@ -6110,8 +6110,8 @@ static int32 orbit_max_min_true_distance_helio(double tjd_et, int ipl, int32 ifl
     ipli = SE_EARTH;
   }
   /* Kepler elements */
-  if ((retval = swe_get_orbital_elements(tjd_et, ipli, iflagi, de, serr)) == ERR)
-    return ERR;
+  if ((retval = swe_get_orbital_elements(tjd_et, ipli, iflagi, de, serr)) == SE_ERR)
+    return SE_ERR;
   *dmax = de[16];
   *dmin = de[15];
   osc_get_orbit_constants(de, pqri);
@@ -6185,10 +6185,10 @@ int32 CALL_CONV swe_orbit_max_min_true_distance(double tjd_et, int32 ipl, int32
     retval = orbit_max_min_true_distance_helio(tjd_et, ipl, iflagi, dmax, dmin, dtrue, serr);
     return retval;
   }
-  if ((retval = swe_get_orbital_elements(tjd_et, ipl, iflagi, dp, serr)) == ERR)
-    return ERR;
-  if ((retval = swe_get_orbital_elements(tjd_et, SE_EARTH, iflagi, de, serr)) == ERR)
-    return ERR;
+  if ((retval = swe_get_orbital_elements(tjd_et, ipl, iflagi, dp, serr)) == SE_ERR)
+    return SE_ERR;
+  if ((retval = swe_get_orbital_elements(tjd_et, SE_EARTH, iflagi, de, serr)) == SE_ERR)
+    return SE_ERR;
   if (de[0] > dp[0]) {
     douter = de;
     dinner = dp;
@@ -6337,7 +6337,7 @@ int32 CALL_CONV swe_gauquelin_sector(
   if (imeth < 0 || imeth > 5) {
     if (serr)
           sprintf(serr, "invalid method: %d", imeth);
-    return ERR;
+    return SE_ERR;
   }
   /* function calls for Pluto with asteroid number 134340
    * are treated as calls for Pluto as main body SE_PLUTO */
@@ -6354,11 +6354,11 @@ int32 CALL_CONV swe_gauquelin_sector(
     nutlo[1] *= RADTODEG;
     armc = swe_degnorm(swe_sidtime0(t_ut, eps + nutlo[1], nutlo[0]) * 15 + geopos[0]);
     if (do_fixstar) {
-      if (swe_fixstar(starname, t_et, iflag, x0, serr) == ERR)
-	return ERR;
+      if (swe_fixstar(starname, t_et, iflag, x0, serr) == SE_ERR)
+	return SE_ERR;
     } else {
-      if (swe_calc(t_et, ipl, iflag, x0, serr) == ERR)
-	return ERR;
+      if (swe_calc(t_et, ipl, iflag, x0, serr) == SE_ERR)
+	return SE_ERR;
     }
     if (imeth == 1) 
       x0[1] = 0;
@@ -6374,10 +6374,10 @@ int32 CALL_CONV swe_gauquelin_sector(
     risemeth |= SE_BIT_DISC_CENTER;
   /* find the next rising time of the planet or star */
   retval = swe_rise_trans(t_ut, ipl, starname, epheflag, SE_CALC_RISE|risemeth, geopos, atpress, attemp, &(tret[0]), serr);
-  if (retval == ERR) {
-    return ERR; 
+  if (retval == SE_ERR) {
+    return SE_ERR; 
   } else if (retval == -2) {
-    /* actually, we could return ERR here. However, we
+    /* actually, we could return SE_ERR here. However, we
      * keep this variable, in case we implement an algorithm
      * for Gauquelin sector positions of circumpolar bodies.
      * As with the Ludwig Otto procedure with Placidus, one 
@@ -6393,8 +6393,8 @@ int32 CALL_CONV swe_gauquelin_sector(
   }
   /* find the next setting time of the planet or star */
   retval = swe_rise_trans(t_ut, ipl, starname, epheflag, SE_CALC_SET|risemeth, geopos, atpress, attemp, &(tret[1]), serr);
-  if (retval == ERR) {
-    return ERR; 
+  if (retval == SE_ERR) {
+    return SE_ERR; 
   } else if (retval == -2) {
     set_found = FALSE;
   }
@@ -6405,8 +6405,8 @@ int32 CALL_CONV swe_gauquelin_sector(
     if (set_found) t = tret[1] - 1.2;
     set_found = TRUE;
     retval = swe_rise_trans(t, ipl, starname, epheflag, SE_CALC_SET|risemeth, geopos, atpress, attemp, &(tret[1]), serr);
-    if (retval == ERR) {
-      return ERR; 
+    if (retval == SE_ERR) {
+      return SE_ERR; 
     } else if (retval == -2) {
       set_found = FALSE;
     }
@@ -6417,8 +6417,8 @@ int32 CALL_CONV swe_gauquelin_sector(
     if (rise_found) t = tret[0] - 1.2;
     rise_found = TRUE;
     retval = swe_rise_trans(t, ipl, starname, epheflag, SE_CALC_RISE|risemeth, geopos, atpress, attemp, &(tret[0]), serr);
-    if (retval == ERR) {
-      return ERR; 
+    if (retval == SE_ERR) {
+      return SE_ERR; 
     } else if (retval == -2) {
       rise_found = FALSE;
     }
@@ -6434,6 +6434,6 @@ int32 CALL_CONV swe_gauquelin_sector(
     *dgsect = 0;
     if (serr)
       sprintf(serr, "rise or set not found for planet %d", ipl);
-    return ERR;
+    return SE_ERR;
   }
 }
diff --git a/src/libswe/swedate.c b/src/libswe/swedate.c
index b31d727..79f7679 100644
--- a/src/libswe/swedate.c
+++ b/src/libswe/swedate.c
@@ -64,7 +64,7 @@
   This function converts some date+time input {y,m,d,uttime}
   into the Julian day number tjd.
   The function checks that the input is a legal combination
-  of dates; for illegal dates like 32 January 1993 it returns ERR
+  of dates; for illegal dates like 32 January 1993 it returns SE_ERR
   but still converts the date correctly, i.e. like 1 Feb 1993.
   The function is usually used to convert user input of birth data
   into the Julian day number. Illegal dates should be notified to the user.
@@ -78,7 +78,7 @@
   etc.
   Many users of Astro programs do not know about this difference.
 
-  Return: OK or ERR (for illegal date)
+  Return: OK or SE_ERR (for illegal date)
 *********************************************************/
 
 # include "swephexp.h"
@@ -106,7 +106,7 @@ int CALL_CONV swe_date_conversion(int y,
   if (rmon == m && rday == d && ryear == y) {
     return OK;
   } else {
-    return ERR;
+    return SE_ERR;
   }
 }
 
@@ -385,7 +385,7 @@ int32 CALL_CONV swe_utc_to_jd(int32 iyear, int32 imonth, int32 iday, int32 ihour
   if (iyear != iyear2 || imonth != imonth2 || iday != iday2) {
     if (serr != NULL)
       sprintf(serr, "invalid date: year = %d, month = %d, day = %d", iyear, imonth, iday);
-    return ERR;
+    return SE_ERR;
   }
   if (ihour < 0 || ihour > 23 
    || imin < 0 || imin > 59 
@@ -393,7 +393,7 @@ int32 CALL_CONV swe_utc_to_jd(int32 iyear, int32 imonth, int32 iday, int32 ihour
    || (dsec >= 60 && (imin < 59 || ihour < 23 || tjd_ut1 < J1972))) {
     if (serr != NULL)
       sprintf(serr, "invalid time: %d:%d:%.2f", ihour, imin, dsec);
-    return ERR;
+    return SE_ERR;
   }
   dhour = (double) ihour + ((double) imin) / 60.0 + dsec / 3600.0;
   /* 
@@ -448,7 +448,7 @@ int32 CALL_CONV swe_utc_to_jd(int32 iyear, int32 imonth, int32 iday, int32 ihour
     if (j != 1) {
       if (serr != NULL)
 	sprintf(serr, "invalid time (no leap second!): %d:%d:%.2f", ihour, imin, dsec);
-      return ERR;
+      return SE_ERR;
     }
   }
   /* 
diff --git a/src/libswe/swehel.c b/src/libswe/swehel.c
index 36fc14f..aa1ab9b 100644
--- a/src/libswe/swehel.c
+++ b/src/libswe/swehel.c
@@ -428,12 +428,12 @@ static int32 calc_rise_and_set(double tjd_start, int32 ipl, double *dgeo, double
   if (swe_calc_ut(tjd0, SE_SUN, iflag, xs, serr) == 0) {
     if (serr != NULL)
       strcpy(serr, "error in calc_rise_and_set(): calc(sun) failed ");
-    return ERR;
+    return SE_ERR;
   }
   if (swe_calc_ut(tjd0, ipl, iflag, xx, serr) == 0) {
     if (serr != NULL)
       strcpy(serr, "error in calc_rise_and_set(): calc(sun) failed ");
-    return ERR;
+    return SE_ERR;
   }
   tjdnoon -= swe_degnorm(xs[0] - xx[0])/360.0 + 0;
   /* is planet above horizon or below? */
@@ -456,10 +456,10 @@ if (eventflag & SE_CALC_RISE) {
   }
 }
   /* position of planet */
-  if (swe_calc_ut(tjdnoon, ipl, iflag, xx, serr) == ERR) {
+  if (swe_calc_ut(tjdnoon, ipl, iflag, xx, serr) == SE_ERR) {
     if (serr != NULL)
       strcpy(serr, "error in calc_rise_and_set(): calc(sun) failed ");
-    return ERR;
+    return SE_ERR;
   }
   /* apparent radius of solar disk (ignoring refraction) */
   rdi = 0;
@@ -490,9 +490,9 @@ else
   if (!(helflag & SE_HELFLAG_HIGH_PRECISION)) 
     iflag |= SEFLG_NONUT|SEFLG_TRUEPOS;
   for (i = 0; i < 2; i++) {
-    if (swe_calc_ut(tjdrise, ipl, iflag, xx, serr) == ERR) {
+    if (swe_calc_ut(tjdrise, ipl, iflag, xx, serr) == SE_ERR) {
       /*fprintf(stderr, "hev4 tjd=%f, ipl=%d, iflag=%d\n", tjdrise, ipl, iflag);*/
-      return ERR;
+      return SE_ERR;
     }
     swe_azalt(tjdrise, SE_EQU2HOR, dgeo, datm[0], datm[1], xx, xaz);
     xx[0] -= xx[3] * dfac; 
@@ -568,7 +568,7 @@ static double SunRA(double JDNDaysUT, int32 helflag, char *serr)
     int32 iflag = epheflag | SEFLG_EQUATORIAL;
     iflag |= SEFLG_NONUT | SEFLG_TRUEPOS;
     tjd_tt = JDNDaysUT + swe_deltat_ex(JDNDaysUT, epheflag, serr);
-    if (swe_calc(tjd_tt, SE_SUN, iflag, x, serr) != ERR) {
+    if (swe_calc(tjd_tt, SE_SUN, iflag, x, serr) != SE_ERR) {
       ralast = x[0];
       tjdlast = JDNDaysUT;
       return ralast;
@@ -695,11 +695,11 @@ static int32 ObjectLoc(double JDNDaysUT, double *dgeo, double *datm, char *Objec
   tjd_tt = JDNDaysUT + swe_deltat_ex(JDNDaysUT, epheflag, serr);
   Planet = DeterObject(ObjectName);
   if (Planet != -1) {
-    if (swe_calc(tjd_tt, Planet, iflag, x, serr) == ERR)
-      return ERR;
+    if (swe_calc(tjd_tt, Planet, iflag, x, serr) == SE_ERR)
+      return SE_ERR;
   } else {
-    if (call_swe_fixstar(ObjectName, tjd_tt, iflag, x, serr) == ERR)
-      return ERR;
+    if (call_swe_fixstar(ObjectName, tjd_tt, iflag, x, serr) == SE_ERR)
+      return SE_ERR;
   }
   if (Angle == 2 ||  Angle == 5) {
     *dret = x[1];
@@ -748,11 +748,11 @@ static int32 azalt_cart(double JDNDaysUT, double *dgeo, double *datm, char *Obje
   tjd_tt = JDNDaysUT + swe_deltat_ex(JDNDaysUT, epheflag, serr);
   Planet = DeterObject(ObjectName);
   if (Planet != -1) {
-    if (swe_calc(tjd_tt, Planet, iflag, x, serr) == ERR)
-      return ERR;
+    if (swe_calc(tjd_tt, Planet, iflag, x, serr) == SE_ERR)
+      return SE_ERR;
   } else {
-    if (call_swe_fixstar(ObjectName, tjd_tt, iflag, x, serr) == ERR)
-      return ERR;
+    if (call_swe_fixstar(ObjectName, tjd_tt, iflag, x, serr) == SE_ERR)
+      return SE_ERR;
   }
   xin[0] = x[0];
   xin[1] = x[1];
@@ -1116,12 +1116,12 @@ static int32 Magnitude(double JDNDaysUT, double *dgeo, char *ObjectName, int32 h
   if (Planet != -1) {
     /**dmag = Phenomena(JDNDaysUT, Lat, Longitude, HeightEye, TempE, PresE, ObjectName, 4);*/
     swe_set_topo(dgeo[0], dgeo[1], dgeo[2]);
-    if (swe_pheno_ut(JDNDaysUT, Planet, iflag, x, serr) == ERR)
-      return ERR;
+    if (swe_pheno_ut(JDNDaysUT, Planet, iflag, x, serr) == SE_ERR)
+      return SE_ERR;
     *dmag = x[4];
   } else {
-    if (call_swe_fixstar_mag(ObjectName, dmag, serr) == ERR)
-      return ERR;
+    if (call_swe_fixstar_mag(ObjectName, dmag, serr) == SE_ERR)
+      return SE_ERR;
   }
   return OK;
 }
@@ -1473,30 +1473,30 @@ int32 CALL_CONV swe_vis_limit_mag(double tjdut, double *dgeo, double *datm, doub
     if (serr != NULL) {
       strcpy(serr, "it makes no sense to call swe_vis_limit_mag() for the Sun");
     }
-    return ERR;
+    return SE_ERR;
   }
   swi_set_tid_acc(tjdut, helflag, 0, serr);
   sunra = SunRA(tjdut, helflag, serr);
   default_heliacal_parameters(datm, dgeo, dobs, helflag);
   swe_set_topo(dgeo[0], dgeo[1], dgeo[2]);
-  if (ObjectLoc(tjdut, dgeo, datm, ObjectName, 0, helflag, &AltO, serr) == ERR)
-    return ERR;
+  if (ObjectLoc(tjdut, dgeo, datm, ObjectName, 0, helflag, &AltO, serr) == SE_ERR)
+    return SE_ERR;
   if (AltO < 0) {
     if (serr != NULL)
       strcpy(serr, "object is below local horizon");
     *dret = -100;
     return -2;
   }
-  if (ObjectLoc(tjdut, dgeo, datm, ObjectName, 1, helflag, &AziO, serr) == ERR)
-    return ERR;
+  if (ObjectLoc(tjdut, dgeo, datm, ObjectName, 1, helflag, &AziO, serr) == SE_ERR)
+    return SE_ERR;
   if (helflag & SE_HELFLAG_VISLIM_DARK) {
     AltS = -90;
     AziS = 0;
   } else {
-    if (ObjectLoc(tjdut, dgeo, datm, "sun", 0, helflag, &AltS, serr) == ERR)
-      return ERR;
-    if (ObjectLoc(tjdut, dgeo, datm, "sun", 1, helflag, &AziS, serr) == ERR)
-      return ERR;
+    if (ObjectLoc(tjdut, dgeo, datm, "sun", 0, helflag, &AltS, serr) == SE_ERR)
+      return SE_ERR;
+    if (ObjectLoc(tjdut, dgeo, datm, "sun", 1, helflag, &AziS, serr) == SE_ERR)
+      return SE_ERR;
   }
   if (strncmp(ObjectName, "moon", 4) == 0 ||
       (helflag & SE_HELFLAG_VISLIM_DARK) ||
@@ -1504,10 +1504,10 @@ int32 CALL_CONV swe_vis_limit_mag(double tjdut, double *dgeo, double *datm, doub
      ) {
     AltM = -90; AziM = 0;
   } else {
-    if (ObjectLoc(tjdut, dgeo, datm, "moon", 0, helflag, &AltM, serr) == ERR)
-      return ERR;
-    if (ObjectLoc(tjdut, dgeo, datm, "moon", 1, helflag, &AziM, serr) == ERR)
-      return ERR;
+    if (ObjectLoc(tjdut, dgeo, datm, "moon", 0, helflag, &AltM, serr) == SE_ERR)
+      return SE_ERR;
+    if (ObjectLoc(tjdut, dgeo, datm, "moon", 1, helflag, &AziM, serr) == SE_ERR)
+      return SE_ERR;
   }
 #if SWEHEL_DEBUG
 {
@@ -1531,12 +1531,12 @@ int32 CALL_CONV swe_vis_limit_mag(double tjdut, double *dgeo, double *datm, doub
   dret[4] = AziS;
   dret[5] = AltM;
   dret[6] = AziM;
-  if (Magnitude(tjdut, dgeo, ObjectName, helflag, &(dret[7]), serr) == ERR)
-    return ERR;
+  if (Magnitude(tjdut, dgeo, ObjectName, helflag, &(dret[7]), serr) == SE_ERR)
+    return SE_ERR;
   retval = scotopic_flag;
   /*dret[8] = (double) is_scotopic;*/
   /*if (*serr != '\0') * in VisLimMagn(), serr is only a warning *
-    retval = ERR; */
+    retval = SE_ERR; */
   return retval;
 }
 
@@ -1566,9 +1566,9 @@ static int32 TopoArcVisionis(double Magn, double *dobs, double AltO, double AziO
   double Xl = 45;
   double Yl, Yr;
   Yl = Magn - VisLimMagn(dobs, AltO, AziO, AltM, AziM, JDNDaysUT, AltO - Xl, AziS, sunra, Lat, HeightEye, datm, helflag, NULL, serr);
-  /* if (*serr != '\0') return ERR; * serr is only a warning */
+  /* if (*serr != '\0') return SE_ERR; * serr is only a warning */
   Yr = Magn - VisLimMagn(dobs, AltO, AziO, AltM, AziM, JDNDaysUT, AltO - xR, AziS, sunra, Lat, HeightEye, datm, helflag, NULL, serr);
-  /* if (*serr != '\0') return ERR; * serr is only a warning */
+  /* if (*serr != '\0') return SE_ERR; * serr is only a warning */
   /* http://en.wikipedia.org/wiki/Bisection_method*/
   if ((Yl * Yr) <= 0) {
     while(fabs(xR - Xl) > epsilon) {
@@ -1577,7 +1577,7 @@ static int32 TopoArcVisionis(double Magn, double *dobs, double AltO, double AziO
       AltSi = AltO - Xm;
       AziSi = AziS;
       Ym = Magn - VisLimMagn(dobs, AltO, AziO, AltM, AziM, JDNDaysUT, AltSi, AziSi, sunra, Lat, HeightEye, datm, helflag, NULL, serr);
-      /* if (*serr != '\0') return ERR; * serr is only a warning */
+      /* if (*serr != '\0') return SE_ERR; * serr is only a warning */
       if ((Yl * Ym) > 0) {
 	/* Throw away left half*/
 	Xl = Xm;
@@ -1604,7 +1604,7 @@ int32 CALL_CONV swe_topo_arcus_visionis(double tjdut, double *dgeo, double *datm
   swi_set_tid_acc(tjdut, helflag, 0, serr);
   sunra = SunRA(tjdut, helflag, serr);
   if (serr != NULL && *serr != '\0')
-    return ERR;
+    return SE_ERR;
   default_heliacal_parameters(datm, dgeo, dobs, helflag);
   return TopoArcVisionis(mag, dobs, alt_obj, azi_obj, alt_moon, azi_moon, tjdut, azi_sun, sunra, dgeo[1], dgeo[2], datm, helflag, dret, serr);
 }
@@ -1651,8 +1651,8 @@ static int32 HeliacalAngle(double Magn, double *dobs, double AziO, double AltM,
   xmin = 0;
   ymin = 10000;
   for (x = minx; x <= maxx; x++) {
-    if (TopoArcVisionis(Magn, dobs, x, AziO, AltM, AziM, JDNDaysUT, AziS, sunra, Lat, HeightEye, datm, helflag, &Arc, serr) == ERR)
-      return ERR;
+    if (TopoArcVisionis(Magn, dobs, x, AziO, AltM, AziM, JDNDaysUT, AziS, sunra, Lat, HeightEye, datm, helflag, &Arc, serr) == SE_ERR)
+      return SE_ERR;
     if (Arc < ymin) {
       ymin = Arc;
       xmin = x;
@@ -1660,20 +1660,20 @@ static int32 HeliacalAngle(double Magn, double *dobs, double AziO, double AltM,
   }
   Xl = xmin - 1;
   xR = xmin + 1;
-  if (TopoArcVisionis(Magn, dobs, xR, AziO, AltM, AziM, JDNDaysUT, AziS, sunra, Lat, HeightEye, datm, helflag, &Yr, serr) == ERR)
-    return ERR;
-  if (TopoArcVisionis(Magn, dobs, Xl, AziO, AltM, AziM, JDNDaysUT, AziS, sunra, Lat, HeightEye, datm, helflag, &Yl, serr) == ERR)
-    return ERR;
+  if (TopoArcVisionis(Magn, dobs, xR, AziO, AltM, AziM, JDNDaysUT, AziS, sunra, Lat, HeightEye, datm, helflag, &Yr, serr) == SE_ERR)
+    return SE_ERR;
+  if (TopoArcVisionis(Magn, dobs, Xl, AziO, AltM, AziM, JDNDaysUT, AziS, sunra, Lat, HeightEye, datm, helflag, &Yl, serr) == SE_ERR)
+    return SE_ERR;
   /* http://en.wikipedia.org/wiki/Bisection_method*/
   while(fabs(xR - Xl) > 0.1) {
     /* Calculate midpoint of domain */
     Xm = (xR + Xl) / 2.0;
     DELTAx = 0.025;
     xmd = Xm + DELTAx;
-    if (TopoArcVisionis(Magn, dobs, Xm, AziO, AltM, AziM, JDNDaysUT, AziS, sunra, Lat, HeightEye, datm, helflag, &Ym, serr) == ERR)
-      return ERR;
-    if (TopoArcVisionis(Magn, dobs, xmd, AziO, AltM, AziM, JDNDaysUT, AziS, sunra, Lat, HeightEye, datm, helflag, &ymd, serr) == ERR)
-      return ERR;
+    if (TopoArcVisionis(Magn, dobs, Xm, AziO, AltM, AziM, JDNDaysUT, AziS, sunra, Lat, HeightEye, datm, helflag, &Ym, serr) == SE_ERR)
+      return SE_ERR;
+    if (TopoArcVisionis(Magn, dobs, xmd, AziO, AltM, AziM, JDNDaysUT, AziS, sunra, Lat, HeightEye, datm, helflag, &ymd, serr) == SE_ERR)
+      return SE_ERR;
     if (Ym >= ymd) {
       /* Throw away left half */
       Xl = Xm;
@@ -1697,7 +1697,7 @@ int32 CALL_CONV swe_heliacal_angle(double tjdut, double *dgeo, double *datm, dou
   if (dgeo[2] < SEI_ECL_GEOALT_MIN || dgeo[2] > SEI_ECL_GEOALT_MAX) {
     if (serr != NULL)
       sprintf(serr, "location for heliacal events must be between %.0f and %.0f m above sea", SEI_ECL_GEOALT_MIN, SEI_ECL_GEOALT_MAX);
-    return ERR;
+    return SE_ERR;
   }
   swi_set_tid_acc(tjdut, helflag, 0, serr);
   default_heliacal_parameters(datm, dgeo, dobs, helflag);
@@ -1760,25 +1760,25 @@ static int32 DeterTAV(double *dobs, double JDNDaysUT, double *dgeo, double *datm
 {
   double Magn, AltO, AziS, AziO, AziM, AltM;
   double sunra = SunRA(JDNDaysUT, helflag, serr);
-  if (Magnitude(JDNDaysUT, dgeo, ObjectName, helflag, &Magn, serr) == ERR)
-    return ERR;
-  if (ObjectLoc(JDNDaysUT, dgeo, datm, ObjectName, 0, helflag, &AltO, serr) == ERR)
-    return ERR;
-  if (ObjectLoc(JDNDaysUT, dgeo, datm, ObjectName, 1, helflag, &AziO, serr) == ERR)
-    return ERR;
+  if (Magnitude(JDNDaysUT, dgeo, ObjectName, helflag, &Magn, serr) == SE_ERR)
+    return SE_ERR;
+  if (ObjectLoc(JDNDaysUT, dgeo, datm, ObjectName, 0, helflag, &AltO, serr) == SE_ERR)
+    return SE_ERR;
+  if (ObjectLoc(JDNDaysUT, dgeo, datm, ObjectName, 1, helflag, &AziO, serr) == SE_ERR)
+    return SE_ERR;
   if (strncmp(ObjectName, "moon", 4) == 0) {
     AltM = -90; 
     AziM = 0;
   } else {
-    if (ObjectLoc(JDNDaysUT, dgeo, datm, "moon", 0, helflag, &AltM, serr) == ERR)
-      return ERR;
-    if (ObjectLoc(JDNDaysUT, dgeo, datm, "moon", 1, helflag, &AziM, serr) == ERR)
-      return ERR;
-  }
-  if (ObjectLoc(JDNDaysUT, dgeo, datm, "sun", 1, helflag, &AziS, serr) == ERR)
-    return ERR;
-  if (TopoArcVisionis(Magn, dobs, AltO, AziO, AltM, AziM, JDNDaysUT, AziS, sunra, dgeo[1], dgeo[2], datm, helflag, dret, serr) == ERR)
-    return ERR;
+    if (ObjectLoc(JDNDaysUT, dgeo, datm, "moon", 0, helflag, &AltM, serr) == SE_ERR)
+      return SE_ERR;
+    if (ObjectLoc(JDNDaysUT, dgeo, datm, "moon", 1, helflag, &AziM, serr) == SE_ERR)
+      return SE_ERR;
+  }
+  if (ObjectLoc(JDNDaysUT, dgeo, datm, "sun", 1, helflag, &AziS, serr) == SE_ERR)
+    return SE_ERR;
+  if (TopoArcVisionis(Magn, dobs, AltO, AziO, AltM, AziM, JDNDaysUT, AziS, sunra, dgeo[1], dgeo[2], datm, helflag, dret, serr) == SE_ERR)
+    return SE_ERR;
   return OK;
 }
 
@@ -1876,7 +1876,7 @@ int32 CALL_CONV swe_heliacal_pheno_ut(double JDNDaysUT, double *dgeo, double *da
   if (dgeo[2] < SEI_ECL_GEOALT_MIN || dgeo[2] > SEI_ECL_GEOALT_MAX) {
     if (serr != NULL)
       sprintf(serr, "location for heliacal events must be between %.0f and %.0f m above sea", SEI_ECL_GEOALT_MIN, SEI_ECL_GEOALT_MAX);
-    return ERR;
+    return SE_ERR;
   }
   swi_set_tid_acc(JDNDaysUT, helflag, 0, serr);
   sunra = SunRA(JDNDaysUT, helflag, serr);
@@ -1895,15 +1895,15 @@ int32 CALL_CONV swe_heliacal_pheno_ut(double JDNDaysUT, double *dgeo, double *da
     retval = ObjectLoc(JDNDaysUT, dgeo, datm, ObjectName, 0, helflag, &AltO, serr);
   if (retval == OK)
     retval = ObjectLoc(JDNDaysUT, dgeo, datm, ObjectName, 7, helflag, &GeoAltO, serr);
-  if (retval == ERR)
-    return ERR;
+  if (retval == SE_ERR)
+    return SE_ERR;
   AppAltO = AppAltfromTopoAlt(AltO, datm[1], datm[0], helflag);
   DAZact = AziS - AziO;
   TAVact = AltO - AltS;
   /*this parallax seems to be somewhat smaller then in Yallop and SkyMap! Needs to be studied*/
   ParO = GeoAltO - AltO;
-  if (Magnitude(JDNDaysUT, dgeo, ObjectName, helflag, &MagnO, serr) == ERR)
-    return ERR;
+  if (Magnitude(JDNDaysUT, dgeo, ObjectName, helflag, &MagnO, serr) == SE_ERR)
+    return SE_ERR;
   ARCVact = TAVact + ParO;
   ARCLact = acos(cos(ARCVact * DEGTORAD) * cos(DAZact * DEGTORAD)) / DEGTORAD;
   Planet = DeterObject(ObjectName);
@@ -1912,7 +1912,7 @@ int32 CALL_CONV swe_heliacal_pheno_ut(double JDNDaysUT, double *dgeo, double *da
     illum = 100;
   } else {
     retval = swe_pheno_ut(JDNDaysUT, Planet, iflag|(SEFLG_TOPOCTR|SEFLG_EQUATORIAL), attr, serr);
-    if (retval == ERR) return ERR;
+    if (retval == SE_ERR) return SE_ERR;
     elong = attr[2];
     illum = attr[1] * 100;
   }
@@ -1943,11 +1943,11 @@ darr[30] = darr[26] + darr[27] + darr[28] + darr[29];
   RS = 2;
   if (TypeEvent == 1 || TypeEvent == 4) RS = 1;
   retval = RiseSet(JDNDaysUT - 4.0 / 24.0, dgeo, datm, "sun", RS, helflag, 0, &RiseSetS, serr);
-  if (retval == ERR)
-    return ERR;
+  if (retval == SE_ERR)
+    return SE_ERR;
   retval = RiseSet(JDNDaysUT - 4.0 / 24.0, dgeo, datm, ObjectName, RS, helflag, 0, &RiseSetO, serr);
-  if (retval == ERR)
-    return ERR;
+  if (retval == SE_ERR)
+    return SE_ERR;
   TbYallop = TJD_INVALID;
   if (retval == -2) { /* object does not rise or set */
     Lag = 0;
@@ -1985,10 +1985,10 @@ darr[30] = darr[26] + darr[27] + darr[28] + darr[29];
       if (retval == OK)
 	retval = ObjectLoc(TimePointer, dgeo, datm, ObjectName, 0, helflag, &AltO2, serr);
       if (retval != OK)
-        return ERR;
+        return SE_ERR;
       DeltaAlt = AltO2 - AltS2;
-      if (DeterTAV(dobs, TimePointer, dgeo, datm, ObjectName, helflag, &MinTAVact, serr) == ERR)
-        return ERR;
+      if (DeterTAV(dobs, TimePointer, dgeo, datm, ObjectName, helflag, &MinTAVact, serr) == SE_ERR)
+        return SE_ERR;
       if (MinTAVoud < MinTAVact && TbVR == 0) {
         /* determine if this is a local minimum with object still above horizon*/
 	TimeCheck = TimePointer + Sgn(TimeStep) * LocalMinStep / 24.0 / 60.0;
@@ -1998,8 +1998,8 @@ darr[30] = darr[26] + darr[27] + darr[28] + darr[29];
 	  else
 	    TimeCheck = mymax(TimeCheck, RiseSetO);
 	}
-        if (DeterTAV(dobs, TimeCheck, dgeo, datm, ObjectName, helflag, &LocalminCheck, serr) == ERR)
-	  return ERR;
+        if (DeterTAV(dobs, TimeCheck, dgeo, datm, ObjectName, helflag, &LocalminCheck, serr) == SE_ERR)
+	  return SE_ERR;
 	if (LocalminCheck > MinTAVact) {
 	  extrax = x2min(MinTAVact, MinTAVoud, OldestMinTAV);
 	  TbVR = TimePointer - (1 - extrax) * TimeStep;
@@ -2128,12 +2128,12 @@ static int32 moon_event_arc_vis(double JDNDaysUTStart, double *dgeo, double *dat
   if (avkind != SE_HELFLAG_AVKIND_VR) {
     if (serr != NULL)
       strcpy(serr, "error: in valid AV kind for the moon");
-    return ERR;
+    return SE_ERR;
   }
   if (TypeEvent == 1 || TypeEvent == 2) {
     if (serr != NULL)
       strcpy(serr, "error: the moon has no morning first or evening last");
-    return ERR;
+    return SE_ERR;
   }
   strcpy(ObjectName, "moon");
   Planet = SE_MOON;
@@ -2183,16 +2183,16 @@ static int32 moon_event_arc_vis(double JDNDaysUTStart, double *dgeo, double *dat
       MinTAVoud = MinTAV;
       DeltaAltoud = DeltaAlt;
       tjd_moonevent = tjd_moonevent - 1.0 / 60.0 / 24.0 * Sgn(Daystep);
-      if (ObjectLoc(tjd_moonevent, dgeo, datm, "sun", 0, helflag, &AltS, serr) == ERR)
-	return ERR;
-      if (ObjectLoc(tjd_moonevent, dgeo, datm, ObjectName, 0, helflag, &AltO, serr) == ERR)
-	return ERR;
+      if (ObjectLoc(tjd_moonevent, dgeo, datm, "sun", 0, helflag, &AltS, serr) == SE_ERR)
+	return SE_ERR;
+      if (ObjectLoc(tjd_moonevent, dgeo, datm, ObjectName, 0, helflag, &AltO, serr) == SE_ERR)
+	return SE_ERR;
       DeltaAlt = AltO - AltS;
-      if (DeterTAV(dobs, tjd_moonevent, dgeo, datm, ObjectName, helflag, &MinTAV, serr) == ERR)
-        return ERR;
+      if (DeterTAV(dobs, tjd_moonevent, dgeo, datm, ObjectName, helflag, &MinTAV, serr) == SE_ERR)
+        return SE_ERR;
       TimeCheck = tjd_moonevent - LocalMinStep / 60.0 / 24.0 * Sgn(Daystep);
-      if (DeterTAV(dobs, TimeCheck, dgeo, datm, ObjectName, helflag, &LocalminCheck, serr) == ERR)
-        return ERR;
+      if (DeterTAV(dobs, TimeCheck, dgeo, datm, ObjectName, helflag, &LocalminCheck, serr) == SE_ERR)
+        return SE_ERR;
 /*printf("%f, %f <= %f\n", tjd_moonevent, MinTAV, MinTAVoud);*/
     /* while (MinTAV <= MinTAVoud && fabs(tjd_moonevent - tjd_moonevent_start) < 120.0 / 60.0 / 24.0);*/
     } while ((MinTAV <= MinTAVoud || LocalminCheck < MinTAV) && fabs(tjd_moonevent - tjd_moonevent_start) < 120.0 / 60.0 / 24.0);
@@ -2202,7 +2202,7 @@ static int32 moon_event_arc_vis(double JDNDaysUTStart, double *dgeo, double *dat
     tjd_moonevent += (1 - x2min(MinTAV, MinTAVoud, OldestMinTAV)) * Sgn(Daystep) / 60.0 / 24.0;
   } else {
     strcpy(serr, "no date found for lunar event");
-    return ERR;
+    return SE_ERR;
   }
   dret[0] = tjd_moonevent;
   return OK;
@@ -2232,7 +2232,7 @@ static int32 heliacal_ut_arc_vis(double JDNDaysUTStart, double *dgeo, double *da
   Pressure = datm[0];
   Temperature = datm[1];
   /* determine Magnitude of star*/
-  if ((retval = Magnitude(JDNDaysUTStart, dgeo, ObjectName, helflag, &objectmagn, serr)) == ERR)
+  if ((retval = Magnitude(JDNDaysUTStart, dgeo, ObjectName, helflag, &objectmagn, serr)) == SE_ERR)
     goto swe_heliacal_err;
   epheflag = helflag & (SEFLG_JPLEPH|SEFLG_SWIEPH|SEFLG_MOSEPH);
   iflag = SEFLG_TOPOCTR | SEFLG_EQUATORIAL | epheflag;
@@ -2291,11 +2291,11 @@ static int32 heliacal_ut_arc_vis(double JDNDaysUTStart, double *dgeo, double *da
 	ArcusVisDeltaoud = ArcusVisDelta;
 	JDNDaysUTstep = JDNDaysUTstep + DayStep;
 	/* determine rise/set time */
-	if ((retval = my_rise_trans(JDNDaysUTstep, SE_SUN, "", eventtype, helflag, dgeo, datm, &tret, serr)) == ERR)
+	if ((retval = my_rise_trans(JDNDaysUTstep, SE_SUN, "", eventtype, helflag, dgeo, datm, &tret, serr)) == SE_ERR)
 	  goto swe_heliacal_err;
 	/* determine time compensation to get Sun's altitude at heliacal rise */
 	tjd_tt = tret + swe_deltat_ex(tret, epheflag, serr);
-	if ((retval = swe_calc(tjd_tt, SE_SUN, iflag, x, serr)) == ERR)
+	if ((retval = swe_calc(tjd_tt, SE_SUN, iflag, x, serr)) == SE_ERR)
 	  goto swe_heliacal_err;
 	xin[0] = x[0];
 	xin[1] = x[1];
@@ -2311,7 +2311,7 @@ static int32 heliacal_ut_arc_vis(double JDNDaysUTStart, double *dgeo, double *da
 	JDNarcvisUT = tret - Tdelta / 24;
 	tjd_tt = JDNarcvisUT + swe_deltat_ex(JDNarcvisUT, epheflag, serr);
 	/* determine Sun's position */
-	if ((retval = swe_calc(tjd_tt, SE_SUN, iflag, x, serr)) == ERR)
+	if ((retval = swe_calc(tjd_tt, SE_SUN, iflag, x, serr)) == SE_ERR)
 	  goto swe_heliacal_err;
 	xin[0] = x[0];
 	xin[1] = x[1];
@@ -2322,7 +2322,7 @@ static int32 heliacal_ut_arc_vis(double JDNDaysUTStart, double *dgeo, double *da
 	/* determine Moon's position */
 #if 0
   double AltM, AziM;
-	if ((retval = swe_calc(tjd_tt, SE_MOON, iflag, x, serr)) == ERR)
+	if ((retval = swe_calc(tjd_tt, SE_MOON, iflag, x, serr)) == SE_ERR)
 	  goto swe_heliacal_err;
 	xin[0] = x[0];
 	xin[1] = x[1];
@@ -2333,13 +2333,13 @@ static int32 heliacal_ut_arc_vis(double JDNDaysUTStart, double *dgeo, double *da
 #endif
 	/* determine object's position */
 	if (Planet != -1) {
-	  if ((retval = swe_calc(tjd_tt, Planet, iflag, x, serr)) == ERR)
+	  if ((retval = swe_calc(tjd_tt, Planet, iflag, x, serr)) == SE_ERR)
 	    goto swe_heliacal_err;
 	  /* determine magnitude of Planet */
-	  if ((retval = Magnitude(JDNarcvisUT, dgeo, ObjectName, helflag, &objectmagn, serr)) == ERR)
+	  if ((retval = Magnitude(JDNarcvisUT, dgeo, ObjectName, helflag, &objectmagn, serr)) == SE_ERR)
 	    goto swe_heliacal_err;
 	} else {
-	  if ((retval = call_swe_fixstar(ObjectName, tjd_tt, iflag, x, serr)) == ERR)
+	  if ((retval = call_swe_fixstar(ObjectName, tjd_tt, iflag, x, serr)) == SE_ERR)
 	    goto swe_heliacal_err;
 	}
 	xin[0] = x[0];
@@ -2350,8 +2350,8 @@ static int32 heliacal_ut_arc_vis(double JDNDaysUTStart, double *dgeo, double *da
 	AltO = xaz[1];
 	/* determine arcusvisionis */
 	DeltaAlt = AltO - AltS;
-	/*if ((retval = HeliacalAngle(objectmagn, dobs, AziO, AltM, AziM, JDNarcvisUT, AziS, dgeo, datm, helflag, dang, serr)) == ERR)*/
-	if ((retval = HeliacalAngle(objectmagn, dobs, AziO, -1, 0, JDNarcvisUT, AziS, dgeo, datm, helflag, dang, serr)) == ERR)
+	/*if ((retval = HeliacalAngle(objectmagn, dobs, AziO, AltM, AziM, JDNarcvisUT, AziS, dgeo, datm, helflag, dang, serr)) == SE_ERR)*/
+	if ((retval = HeliacalAngle(objectmagn, dobs, AziO, -1, 0, JDNarcvisUT, AziS, dgeo, datm, helflag, dang, serr)) == SE_ERR)
 	  goto swe_heliacal_err;
 	ArcusVis = dang[1];
 	ArcusVisPto = dang[2];
@@ -2377,7 +2377,7 @@ static int32 heliacal_ut_arc_vis(double JDNDaysUTStart, double *dgeo, double *da
   if (helflag & SE_HELFLAG_AVKIND_VR) {
     double darr[40];
     if (swe_heliacal_pheno_ut(JDNarcvisUT, dgeo, datm, dobs, ObjectName, TypeEvent, helflag, darr, serr) != OK)
-      return ERR;
+      return SE_ERR;
     JDNarcvisUT = darr[13];
     }
   }
@@ -2389,11 +2389,11 @@ static int32 heliacal_ut_arc_vis(double JDNDaysUTStart, double *dgeo, double *da
     TimeStep = direct;
     TbVR = 0;
     TimePointer = JDNarcvisUT;
-    if (DeterTAV(dobs, TimePointer, dgeo, datm, ObjectName, helflag, &OldestMinTAV, serr) == ERR)
-      return ERR;
+    if (DeterTAV(dobs, TimePointer, dgeo, datm, ObjectName, helflag, &OldestMinTAV, serr) == SE_ERR)
+      return SE_ERR;
     TimePointer = TimePointer + TimeStep;
-    if (DeterTAV(dobs, TimePointer, dgeo, datm, ObjectName, helflag, &MinTAVoud, serr) == ERR)
-      return ERR;
+    if (DeterTAV(dobs, TimePointer, dgeo, datm, ObjectName, helflag, &MinTAVoud, serr) == SE_ERR)
+      return SE_ERR;
     if (MinTAVoud > OldestMinTAV) {
       TimePointer = JDNarcvisUT;
       TimeStep = -TimeStep;
@@ -2407,8 +2407,8 @@ static int32 heliacal_ut_arc_vis(double JDNDaysUTStart, double *dgeo, double *da
       TimePointer = TimePointer + TimeStep;
       OldestMinTAV = MinTAVoud;
       MinTAVoud = MinTAVact;
-      if (DeterTAV(dobs, TimePointer, dgeo, datm, ObjectName, helflag, &MinTAVact, serr) == ERR)
-        return ERR;
+      if (DeterTAV(dobs, TimePointer, dgeo, datm, ObjectName, helflag, &MinTAVact, serr) == SE_ERR)
+        return SE_ERR;
       if (MinTAVoud < MinTAVact) {
 	extrax = x2min(MinTAVact, MinTAVoud, OldestMinTAV);
 	TbVR = TimePointer - (1 - extrax) * TimeStep;
@@ -2423,10 +2423,10 @@ static int32 heliacal_ut_arc_vis(double JDNDaysUTStart, double *dgeo, double *da
       JDNarcvisUT = JDNarcvisUT - direct;
       tjd_tt = JDNarcvisUT + swe_deltat_ex(JDNarcvisUT, epheflag, serr);
       if (Planet != -1) {
-	if ((retval = swe_calc(tjd_tt, Planet, iflag, x, serr)) == ERR)
+	if ((retval = swe_calc(tjd_tt, Planet, iflag, x, serr)) == SE_ERR)
 	  goto swe_heliacal_err;
       } else {
-	if ((retval = call_swe_fixstar(ObjectName, tjd_tt, iflag, x, serr)) == ERR)
+	if ((retval = call_swe_fixstar(ObjectName, tjd_tt, iflag, x, serr)) == SE_ERR)
 	  goto swe_heliacal_err;
       }
       xin[0] = x[0];
@@ -2439,7 +2439,7 @@ static int32 heliacal_ut_arc_vis(double JDNDaysUTStart, double *dgeo, double *da
   if (JDNarcvisUT < -9999999 || JDNarcvisUT > 9999999) {
     dret[0] = JDNDaysUT; /* no date found, just return input */
     strcpy(serr, "no heliacal date found");
-    retval = ERR;
+    retval = SE_ERR;
     goto swe_heliacal_err;
   }
   dret[0] = JDNarcvisUT;
@@ -2459,11 +2459,11 @@ static int32 get_asc_obl(double tjd, int32 ipl, char *star, int32 iflag, double
   char star2[AS_MAXCH];
   strcpy(star2, star);
   if (ipl == -1) {
-    if ((retval = swe_fixstar(star2, tjd, epheflag | SEFLG_EQUATORIAL, x, serr)) == ERR)
-      return ERR;
+    if ((retval = swe_fixstar(star2, tjd, epheflag | SEFLG_EQUATORIAL, x, serr)) == SE_ERR)
+      return SE_ERR;
   } else {
-    if ((retval = swe_calc(tjd, ipl, epheflag | SEFLG_EQUATORIAL, x, serr)) == ERR)
-      return ERR;
+    if ((retval = swe_calc(tjd, ipl, epheflag | SEFLG_EQUATORIAL, x, serr)) == SE_ERR)
+      return SE_ERR;
   }
   adp = tan(dgeo[1] * DEGTORAD) * tan(x[1] * DEGTORAD);
   if (fabs(adp) > 1) {
@@ -2491,11 +2491,11 @@ static int32 get_asc_obl_old(double tjd, int32 ipl, char *star, int32 iflag, dou
   double x[6], adp;
   char s[AS_MAXCH];
   if (star != NULL && *star != '\0') {
-    if ((retval = call_swe_fixstar(star, tjd, epheflag | SEFLG_EQUATORIAL, x, serr)) == ERR)
-      return ERR;
+    if ((retval = call_swe_fixstar(star, tjd, epheflag | SEFLG_EQUATORIAL, x, serr)) == SE_ERR)
+      return SE_ERR;
   } else {
-    if ((retval = swe_calc(tjd, ipl, epheflag | SEFLG_EQUATORIAL, x, serr)) == ERR)
-      return ERR;
+    if ((retval = swe_calc(tjd, ipl, epheflag | SEFLG_EQUATORIAL, x, serr)) == SE_ERR)
+      return SE_ERR;
   }
   adp = tan(dgeo[1] * DEGTORAD) * tan(x[1] * DEGTORAD); 
   if (fabs(adp) > 1) {
@@ -2589,10 +2589,10 @@ static int32 find_conjunct_sun(double tjd_start, int32 ipl, int32 helflag, int32
   tjdcon = tjd0 + ((floor) ((tjd_start - tjd0) / dsynperiod) + 1) * dsynperiod;
   ds = 100;
   while (ds > 0.5) {
-    if (swe_calc(tjdcon, ipl, epheflag|SEFLG_SPEED, x, serr) == ERR)
-      return ERR;
-    if (swe_calc(tjdcon, SE_SUN, epheflag|SEFLG_SPEED, xs, serr) == ERR)
-      return ERR;
+    if (swe_calc(tjdcon, ipl, epheflag|SEFLG_SPEED, x, serr) == SE_ERR)
+      return SE_ERR;
+    if (swe_calc(tjdcon, SE_SUN, epheflag|SEFLG_SPEED, xs, serr) == SE_ERR)
+      return SE_ERR;
     ds = swe_degnorm(x[0] - xs[0] - daspect);
     if (ds > 180) ds -= 360;
     tjdcon -= ds / (x[3] - xs[3]);
@@ -2625,7 +2625,7 @@ static int32 get_asc_obl_with_sun(double tjd_start, int32 ipl, char *star, int32
   tjd = tjd_start;
   dsunpl_save = -999999999;
   retval = get_asc_obl_diff(tjd, ipl, star, epheflag, dgeo, desc_obl, is_acronychal, &dsunpl, serr);
-  if (retval != OK)  /* retval may be ERR or -2 */
+  if (retval != OK)  /* retval may be SE_ERR or -2 */
     return retval;
   daystep = 20;
   i = 0;
@@ -2637,28 +2637,28 @@ static int32 get_asc_obl_with_sun(double tjd_start, int32 ipl, char *star, int32
     i++;
     if (i > 5000) {
       sprintf(serr, "loop in get_asc_obl_with_sun() (1)");
-      return ERR;
+      return SE_ERR;
     }
     dsunpl_save = dsunpl;
     tjd += 10.0;
     if (dperiod > 0 && tjd - tjd_start > dperiod)
       return -2;
     retval = get_asc_obl_diff(tjd, ipl, star, epheflag, dgeo, desc_obl, is_acronychal, &dsunpl, serr);
-    if (retval != OK)  /* retval may be ERR or -2 */
+    if (retval != OK)  /* retval may be SE_ERR or -2 */
       return retval;
   }
   tjd_start = tjd - daystep;
   daystep /= 2.0;
   tjd = tjd_start + daystep;
   retval = get_asc_obl_diff(tjd, ipl, star, epheflag, dgeo, desc_obl, is_acronychal, &dsunpl_test, serr);
-  if (retval != OK)  /* retval may be ERR or -2 */
+  if (retval != OK)  /* retval may be SE_ERR or -2 */
     return retval;
   i = 0;
   while (fabs(dsunpl) > 0.00001) {
     i++;
     if (i > 5000) {
       sprintf(serr, "loop in get_asc_obl_with_sun() (2)");
-      return ERR;
+      return SE_ERR;
     }
     if (dsunpl_save * dsunpl_test >= 0) {
       dsunpl_save = dsunpl_test;
@@ -2669,7 +2669,7 @@ static int32 get_asc_obl_with_sun(double tjd_start, int32 ipl, char *star, int32
     daystep /= 2.0;
     tjd = tjd_start + daystep;
     retval = get_asc_obl_diff(tjd, ipl, star, epheflag, dgeo, desc_obl, is_acronychal, &dsunpl_test, serr);
-    if (retval != OK)  /* retval may be ERR or -2 */
+    if (retval != OK)  /* retval may be SE_ERR or -2 */
       return retval;
   }
   *tjdret = tjd;
@@ -2694,13 +2694,13 @@ static int32 get_asc_obl_with_sun_old(double tjd_start, int32 ipl, char *star, i
   daystep = dsynperiod;
   tjd = tjd_start;
   retval = get_asc_obl_diff(tjd, ipl, star, epheflag, dgeo, desc_obl, &dsunpl, serr);
-  if (retval != OK)  /* retval may be ERR or -2 */
+  if (retval != OK)  /* retval may be SE_ERR or -2 */
     return retval;
   while (dsunpl < 359.99999) {
     dsunpl_save = dsunpl;
     daystep /= 2.0;
     retval = get_asc_obl_diff(tjd + daystep, ipl, star, epheflag, dgeo, desc_obl, &dsunpl, serr);
-    if (retval != OK)  /* retval may be ERR or -2 */
+    if (retval != OK)  /* retval may be SE_ERR or -2 */
       return retval;
     if (dsunpl > dsunpl_save)
       tjd += daystep;
@@ -2730,11 +2730,11 @@ static int32 get_asc_obl_acronychal(double tjd_start, int32 ipl, char *star, int
   }
   /* ascensio (descensio) obliqua of sun */
   retval = get_asc_obl(tjd, SE_SUN, "", epheflag, dgeo, sun_desc, &aosun, serr);
-  if (retval != OK)  /* retval may be ERR or -2 */
+  if (retval != OK)  /* retval may be SE_ERR or -2 */
     return retval;
   /* ascensio (descensio) obliqua of body */
   retval = get_asc_obl(tjd, ipl, star, epheflag, dgeo, obj_desc, &aopl, serr);
-  if (retval != OK)  /* retval may be ERR or -2 */
+  if (retval != OK)  /* retval may be SE_ERR or -2 */
     return retval;
   dsunpl = swe_degnorm(aosun - aopl + 180);
   while (dsunpl < 359.99999) {
@@ -2742,11 +2742,11 @@ static int32 get_asc_obl_acronychal(double tjd_start, int32 ipl, char *star, int
     daystep /= 2.0;
     /* ascensio (descensio) obliqua of sun */
     retval = get_asc_obl(tjd+daystep, SE_SUN, "", epheflag, dgeo, sun_desc, &aosun, serr);
-    if (retval != OK)  /* retval may be ERR or -2 */
+    if (retval != OK)  /* retval may be SE_ERR or -2 */
       return retval;
     /* ascensio (descensio) obliqua of body */
     retval = get_asc_obl(tjd+daystep, ipl, star, epheflag, dgeo, obj_desc, &aopl, serr);
-    if (retval != OK)  /* retval may be ERR or -2 */
+    if (retval != OK)  /* retval may be SE_ERR or -2 */
       return retval;
     dsunpl = swe_degnorm(aosun - aopl + 180);
     if (dsunpl > dsunpl_save)
@@ -2817,8 +2817,8 @@ static int32 get_heliacal_day(double tjd, double *dgeo, double *datm, double *do
       break; 
     case -1:
       ndays = 300;
-      if (call_swe_fixstar_mag(ObjectName, &dmag, serr) == ERR) {
-	return ERR;
+      if (call_swe_fixstar_mag(ObjectName, &dmag, serr) == SE_ERR) {
+	return SE_ERR;
       }
       daystep = 15;
       tfac = 10;
@@ -2843,8 +2843,8 @@ static int32 get_heliacal_day(double tjd, double *dgeo, double *datm, double *do
     vdelta = -100; 
     if (i > 0)
       tday -= 0.3 * direct_day;
-    if ((retval = my_rise_trans(tday, SE_SUN, "", is_rise_or_set, helflag, dgeo, datm, &tret, serr)) == ERR) {
-      return ERR;
+    if ((retval = my_rise_trans(tday, SE_SUN, "", is_rise_or_set, helflag, dgeo, datm, &tret, serr)) == SE_ERR) {
+      return SE_ERR;
     }
     /* sun does not rise: try next day */
     if (retval == -2) {
@@ -2852,8 +2852,8 @@ static int32 get_heliacal_day(double tjd, double *dgeo, double *datm, double *do
       continue;
     }
     retval = swe_vis_limit_mag(tret, dgeo, datm, dobs, ObjectName, helflag, darr, serr);
-    if (retval == ERR)
-      return ERR;
+    if (retval == SE_ERR)
+      return SE_ERR;
 #if 1
     /*  object has appeared above horizon: reduce daystep */
     if (retval_old == -2 && retval >= 0 && daystep > 1) {
@@ -2890,8 +2890,8 @@ static int32 get_heliacal_day(double tjd, double *dgeo, double *datm, double *do
       else 
 	tret += 1.0 / div * direct_time;
       retval = swe_vis_limit_mag(tret, dgeo, datm, dobs, ObjectName, helflag, darr, serr);
-      if (retval == ERR)
-	return ERR;
+      if (retval == SE_ERR)
+	return SE_ERR;
     }
     /* if possible move a bit away from sunset, where vis_limit_mag() has strange behaviour */
     if (visible_at_sunsetrise) {
@@ -2928,7 +2928,7 @@ static int32 time_optimum_visibility(double tjd, double *dgeo, double *datm, dou
   int t_has_changed;
   *tret = tjd;
   retval = swe_vis_limit_mag(tjd, dgeo, datm, dobs, ObjectName, helflag, darr, serr);
-  if (retval == ERR) return ERR;
+  if (retval == SE_ERR) return SE_ERR;
   retval_sv = retval;
   //vl = darr[0] - darr[7];
   //vl = -1;
@@ -2954,7 +2954,7 @@ static int32 time_optimum_visibility(double tjd, double *dgeo, double *datm, dou
     }
     if (t_has_changed == 0)
       t1 -= d; /* revert initial addition */
-    if (retval == ERR) return ERR;
+    if (retval == SE_ERR) return SE_ERR;
   }
   for (i = 0, d = 100.0 / 86400.0; i < 3; i++, d /= 10.0) {
     t2 -= d;
@@ -2971,7 +2971,7 @@ static int32 time_optimum_visibility(double tjd, double *dgeo, double *datm, dou
     }
     if (t_has_changed == 0)
       t2 += d; /* revert initial subtraction */
-    if (retval == ERR) return ERR;
+    if (retval == SE_ERR) return SE_ERR;
   }
   if (vl2 > vl1) 
     tjd = t2;
@@ -3008,7 +3008,7 @@ static int32 time_limit_invisible(double tjd, double *dgeo, double *datm, double
     ncnt = 4;
   }
   retval = swe_vis_limit_mag(tjd + d * direct, dgeo, datm, dobs, ObjectName, helflag, darr, serr);
-  if (retval == ERR) return ERR;
+  if (retval == SE_ERR) return SE_ERR;
   retval_sv = retval;
   phot_scot_opic_sv = retval & SE_SCOTOPIC_FLAG;
   for (i = 0, d = d0; i < ncnt; i++, d /= 10.0) {
@@ -3070,30 +3070,30 @@ static int32 get_acronychal_day(double tjd, double *dgeo, double *datm, double *
     tjd += 0.7 * direct;
     if (direct < 0) tjd -= 1;
     retval = my_rise_trans(tjd, ipl, ObjectName, is_rise_or_set, helflag, dgeo, datm, &tjd, serr);
-    if (retval == ERR) return ERR;
+    if (retval == SE_ERR) return SE_ERR;
     retval = swe_vis_limit_mag(tjd, dgeo, datm, dobs, ObjectName, helflag, darr, serr);
-    if (retval == ERR) return ERR;
+    if (retval == SE_ERR) return SE_ERR;
     while(darr[0] < darr[7]) {
       tjd += 10.0 / 1440.0 * -direct;
       retval = swe_vis_limit_mag(tjd, dgeo, datm, dobs, ObjectName, helflag, darr, serr);
-      if (retval == ERR) return ERR;
+      if (retval == SE_ERR) return SE_ERR;
     }
     retval = time_limit_invisible(tjd, dgeo, datm, dobs, ObjectName, helflag | SE_HELFLAG_VISLIM_DARK, direct, &tret_dark, serr);
-    if (retval == ERR) return ERR;
+    if (retval == SE_ERR) return SE_ERR;
     retval = time_limit_invisible(tjd, dgeo, datm, dobs, ObjectName, helflag | SE_HELFLAG_VISLIM_NOMOON, direct, &tret, serr);
-    if (retval == ERR) return ERR;
+    if (retval == SE_ERR) return SE_ERR;
 #if 0
-    if (azalt_cart(tret_dark, dgeo, datm, ObjectName, helflag, darr, serr) == ERR)
-      return ERR;
-    if (azalt_cart(tret, dgeo, datm, ObjectName, helflag, darr+6, serr) == ERR)
-      return ERR;
+    if (azalt_cart(tret_dark, dgeo, datm, ObjectName, helflag, darr, serr) == SE_ERR)
+      return SE_ERR;
+    if (azalt_cart(tret, dgeo, datm, ObjectName, helflag, darr+6, serr) == SE_ERR)
+      return SE_ERR;
     dtret = acos(swi_dot_prod_unit(darr+3, darr+9)) / DEGTORAD;
 #else
     dtret = fabs(tret - tret_dark);
 #endif
   }
-  if (azalt_cart(tret, dgeo, datm, "sun", helflag, darr, serr) == ERR)
-    return ERR;
+  if (azalt_cart(tret, dgeo, datm, "sun", helflag, darr, serr) == SE_ERR)
+    return SE_ERR;
   *thel = tret;
   if (darr[1] < -12) {
     sprintf(serr, "acronychal rising/setting not available, %f", darr[1]);
@@ -3111,7 +3111,7 @@ static int32 get_heliacal_details(double tday, double *dgeo, double *datm, doubl
   /* find next optimum visibility */
   optimum_undefined = FALSE;
   retval = time_optimum_visibility(tday, dgeo, datm, dobs, ObjectName, helflag, &(dret[1]), serr);
-  if (retval == ERR) return ERR;
+  if (retval == SE_ERR) return SE_ERR;
   if (retval == -2) {
     retval = OK;
     optimum_undefined = TRUE; /* change photopic <-> scotopic vision */
@@ -3122,7 +3122,7 @@ static int32 get_heliacal_details(double tday, double *dgeo, double *datm, doubl
     direct = -1;
   limit_1_undefined = FALSE;
   retval = time_limit_invisible(tday, dgeo, datm, dobs, ObjectName, helflag, direct, &(dret[0]), serr);
-  if (retval == ERR) return ERR;
+  if (retval == SE_ERR) return SE_ERR;
   if (retval == -2) {
     retval = OK;
     limit_1_undefined = TRUE; /* change photopic <-> scotopic vision */
@@ -3131,7 +3131,7 @@ static int32 get_heliacal_details(double tday, double *dgeo, double *datm, doubl
   direct *= -1;
   limit_2_undefined = FALSE;
   retval = time_limit_invisible(dret[1], dgeo, datm, dobs, ObjectName, helflag, direct, &(dret[2]), serr);
-  if (retval == ERR) return ERR;
+  if (retval == SE_ERR) return SE_ERR;
   if (retval == -2) {
     retval = OK;
     limit_2_undefined = TRUE; /* change photopic <-> scotopic vision */
@@ -3192,10 +3192,10 @@ static int32 heliacal_ut_vis_lim(double tjd_start, double *dgeo, double *datm, d
       /* find date when star rises with sun (cosmic rising) */
     retval = get_asc_obl_with_sun(tjd, ipl, ObjectName, helflag, TypeEvent, 0, dgeo, &tjd, serr);
       if (retval != OK)
-	goto swe_heliacal_err; /* retval may be -2 or ERR */
+	goto swe_heliacal_err; /* retval may be -2 or SE_ERR */
     } else {
       /* find date of conjunction of object with sun */
-      if ((retval = find_conjunct_sun(tjd, ipl, helflag, TypeEvent, &tjd, serr)) == ERR) {
+      if ((retval = find_conjunct_sun(tjd, ipl, helflag, TypeEvent, &tjd, serr)) == SE_ERR) {
 	goto swe_heliacal_err;
       }
     }
@@ -3214,7 +3214,7 @@ static int32 heliacal_ut_vis_lim(double tjd_start, double *dgeo, double *datm, d
 	goto swe_heliacal_err;
     } else {
       /* find date of conjunction of object with sun */
-      if ((retval = find_conjunct_sun(tjd, ipl, helflag, TypeEvent, &tjd, serr)) == ERR)
+      if ((retval = find_conjunct_sun(tjd, ipl, helflag, TypeEvent, &tjd, serr)) == SE_ERR)
 	goto swe_heliacal_err;
     }
     tday = tjd;
@@ -3230,7 +3230,7 @@ static int32 heliacal_ut_vis_lim(double tjd_start, double *dgeo, double *datm, d
      */
     if (ipl == SE_MERCURY || ipl == SE_VENUS || TypeEvent <= 2) {
       retval = get_heliacal_details(tday, dgeo, datm, dobs, ObjectName, TypeEvent, helflag2, dret, serr);
-      if (retval == ERR) goto swe_heliacal_err;
+      if (retval == SE_ERR) goto swe_heliacal_err;
     } else if ((0)) {
       if (TypeEvent == 4 || TypeEvent == 6) direct = -1;
       for (i = 0, d = 100.0 / 86400.0; i < 3; i++, d /= 10.0) {
@@ -3261,7 +3261,7 @@ static int32 moon_event_vis_lim(double tjdstart, double *dgeo, double *datm, dou
   if (TypeEvent == 1 || TypeEvent == 2) {
     if (serr_ret != NULL)
       strcpy(serr_ret, "error: the moon has no morning first or evening last");
-    return ERR;
+    return SE_ERR;
   }
   strcpy(ObjectName, "moon");
   ipl = SE_MOON;
@@ -3273,8 +3273,8 @@ static int32 moon_event_vis_lim(double tjdstart, double *dgeo, double *datm, dou
   /* check Synodic/phase Period */
   tjd = tjdstart - 30; /* -50 makes sure, that no event is missed, 
                          * but may return an event before start date */
-  if ((retval = find_conjunct_sun(tjd, ipl, helflag, TypeEvent, &tjd, serr)) == ERR)
-    return ERR;
+  if ((retval = find_conjunct_sun(tjd, ipl, helflag, TypeEvent, &tjd, serr)) == SE_ERR)
+    return SE_ERR;
   /* find the day and minute on which the object becomes visible */
   retval = get_heliacal_day(tjd, dgeo, datm, dobs, ObjectName, helflag2, TypeEvent, &tjd, serr); 
   if (retval != OK)
@@ -3282,7 +3282,7 @@ static int32 moon_event_vis_lim(double tjdstart, double *dgeo, double *datm, dou
   dret[0] = tjd;
   /* find next optimum visibility */
   retval = time_optimum_visibility(tjd, dgeo, datm, dobs, ObjectName, helflag, &tjd, serr);
-  if (retval == ERR) goto moon_event_err;
+  if (retval == SE_ERR) goto moon_event_err;
   dret[1] = tjd;
   /* find moment of becoming visible */
   /* Note: On the day of first light the moon may become visible 
@@ -3292,18 +3292,18 @@ static int32 moon_event_vis_lim(double tjdstart, double *dgeo, double *datm, dou
   if (TypeEvent == 4)
     direct = -1;
   retval = time_limit_invisible(tjd, dgeo, datm, dobs, ObjectName, helflag, direct, &tjd, serr);
-  if (retval == ERR) goto moon_event_err;
+  if (retval == SE_ERR) goto moon_event_err;
   dret[2] = tjd;
   /* find moment of end of visibility */
   direct *= -1;
   retval = time_limit_invisible(dret[1], dgeo, datm, dobs, ObjectName, helflag, direct, &tjd, serr);
   dret[0] = tjd;
-  if (retval == ERR) goto moon_event_err;
+  if (retval == SE_ERR) goto moon_event_err;
 #if 1
   /* if the moon is visible before sunset, we return sunset as start time */
   if (TypeEvent == 3) {
-    if ((retval = my_rise_trans(tjd, SE_SUN, "", SE_CALC_SET, helflag, dgeo, datm, &trise, serr)) == ERR)
-      return ERR;
+    if ((retval = my_rise_trans(tjd, SE_SUN, "", SE_CALC_SET, helflag, dgeo, datm, &trise, serr)) == SE_ERR)
+      return SE_ERR;
     if (trise < dret[1]) {
       dret[0] = trise;
       /* do not warn, it happens too often */
@@ -3311,8 +3311,8 @@ static int32 moon_event_vis_lim(double tjdstart, double *dgeo, double *datm, dou
     }
   /* if the moon is visible after sunrise, we return sunrise as end time */
   } else {
-    if ((retval = my_rise_trans(dret[1], SE_SUN, "", SE_CALC_RISE, helflag, dgeo, datm, &trise, serr)) == ERR)
-      return ERR;
+    if ((retval = my_rise_trans(dret[1], SE_SUN, "", SE_CALC_RISE, helflag, dgeo, datm, &trise, serr)) == SE_ERR)
+      return SE_ERR;
     if (dret[0] > trise) {
       dret[0] = trise;
       /* do not warn, it happens too often */
@@ -3400,7 +3400,7 @@ int32 CALL_CONV swe_heliacal_ut(double JDNDaysUTStart, double *dgeo, double *dat
   if (dgeo[2] < SEI_ECL_GEOALT_MIN || dgeo[2] > SEI_ECL_GEOALT_MAX) {
     if (serr_ret != NULL)
       sprintf(serr_ret, "location for heliacal events must be between %.0f and %.0f m above sea\n", SEI_ECL_GEOALT_MIN, SEI_ECL_GEOALT_MAX);
-    return ERR;
+    return SE_ERR;
   }
   swi_set_tid_acc(JDNDaysUTStart, helflag, 0, serr);
   if (helflag & SE_HELFLAG_LONG_SEARCH)
@@ -3420,7 +3420,7 @@ int32 CALL_CONV swe_heliacal_ut(double JDNDaysUTStart, double *dgeo, double *dat
     if (serr_ret != NULL) {
       strcpy(serr_ret, "the sun has no heliacal rising or setting\n");
     }
-    return ERR;
+    return SE_ERR;
   }
   /* 
    * Moon events
@@ -3430,7 +3430,7 @@ int32 CALL_CONV swe_heliacal_ut(double JDNDaysUTStart, double *dgeo, double *dat
       if (serr_ret != NULL) {
         sprintf(serr_ret, "%s (event type %d) does not exist for the moon\n", sevent[TypeEvent], TypeEvent);
       }
-      return ERR;
+      return SE_ERR;
     }
     tjd = tjd0;
     retval = MoonEventJDut(tjd, dgeo, datm, dobs, TypeEvent, helflag, dret, serr);
@@ -3456,7 +3456,7 @@ int32 CALL_CONV swe_heliacal_ut(double JDNDaysUTStart, double *dgeo, double *dat
 	    swe_get_planet_name(Planet, s);
 	  sprintf(serr_ret, "%s (event type %d) does not exist for %s\n", sevent[TypeEvent], TypeEvent, s);
 	}
-	return ERR;
+	return SE_ERR;
       }
     }
   }
@@ -3479,7 +3479,7 @@ int32 CALL_CONV swe_heliacal_ut(double JDNDaysUTStart, double *dgeo, double *dat
 	  swe_get_planet_name(Planet, s);
 	sprintf(serr_ret, "%s (event type %d) is not provided for %s\n", sevent[TypeEvent], TypeEvent, s);
       }
-      return ERR;
+      return SE_ERR;
     }
   }
   dsynperiod = get_synodic_period(Planet);
@@ -3514,7 +3514,7 @@ int32 CALL_CONV swe_heliacal_ut(double JDNDaysUTStart, double *dgeo, double *dat
     retval = -2;
   } else if (retval == -2) {
     sprintf(serr, "no heliacal date found within %d synodic periods", MaxCountSynodicPeriod);
-    retval = ERR;
+    retval = SE_ERR;
   }
   if (serr_ret != NULL && *serr != '\0')
     strcpy(serr_ret, serr);
diff --git a/src/libswe/swehouse.c b/src/libswe/swehouse.c
index 869035b..2e64360 100644
--- a/src/libswe/swehouse.c
+++ b/src/libswe/swehouse.c
@@ -149,7 +149,7 @@ int CALL_CONV swe_houses(double tjd_ut,
     if (result < 0) {
       // in case of failure, Porphyry houses
       result = swe_houses_armc_ex2(armc, geolat, eps + nutlo[1], 'O', cusp, ascmc, NULL, NULL, NULL);
-      return ERR;
+      return SE_ERR;
     }
     ascmc[9] = xp[1];	// declination in ascmc[9];
   }
@@ -187,7 +187,7 @@ int CALL_CONV swe_houses_ex(double tjd_ut,
 }
 
 /* 
- * Function returns OK or ERR.
+ * Function returns OK or SE_ERR.
  * cusps are returned in double cusp[13],
  *                           or cusp[37] with house system 'G'.
  * cusp[1...12]	  houses 1 - 12
@@ -599,7 +599,7 @@ int CALL_CONV swe_houses_armc(
 }
 
 /* 
- * Function returns OK or ERR.
+ * Function returns OK or SE_ERR.
  * this function is required for very special computations
  * where no date is given for house calculation,
  * e.g. for composite charts or progressive charts.
@@ -1109,7 +1109,7 @@ static int CalcH(
     } else {
       retc = sunshine_solution_makransky(th, fi, ekl, hsp);
     }
-    if (retc == ERR) {	// only Makransky version does this
+    if (retc == SE_ERR) {	// only Makransky version does this
       strcpy(hsp->serr, "within polar circle, switched to Porphyry"); 
       hsy = 'O';
       goto porphyry;
@@ -1118,7 +1118,7 @@ static int CalcH(
     break;
   case 'K': /* Koch houses */
     if (fabs(fi) >= 90 - ekl) {  /* within polar circle */
-      retc = ERR;
+      retc = SE_ERR;
       strcpy(hsp->serr, "within polar circle, switched to Porphyry"); 
       goto porphyry;
     }
@@ -1490,7 +1490,7 @@ porphyry:
       hsp->cusp_speed[i] = 0;
     }
     if (fabs(fi) >= 90 - ekl) {  /* within polar circle */
-      retc = ERR;
+      retc = SE_ERR;
       strcpy(hsp->serr, "within polar circle, switched to Porphyry"); 
       hsy = (int) 'O';
       goto porphyry;
@@ -1529,7 +1529,7 @@ porphyry:
   fprintf(stderr, "h=%d, niter=%d\n", ih, i);
 #endif
 	if (i >= niter_max) {
-	  retc = ERR;
+	  retc = SE_ERR;
 	  hsy = (int) 'O';
 	  strcpy(hsp->serr, "very close to polar circle, switched to Porphyry"); 
 	  goto porphyry;
@@ -1571,7 +1571,7 @@ porphyry:
   fprintf(stderr, "h=%d, niter=%d\n", ih, i);
 #endif
 	if (i >= niter_max) {
-	  retc = ERR;
+	  retc = SE_ERR;
 	  hsy = (int) 'O';
 	  strcpy(hsp->serr, "very close to polar circle, switched to Porphyry"); 
 	  goto porphyry;
@@ -1693,7 +1693,7 @@ porphyry:
     break;
   default:	/* Placidus houses */
     if (fabs(fi) >= 90 - ekl) {  /* within polar circle */
-      retc = ERR;
+      retc = SE_ERR;
       strcpy(hsp->serr, "within polar circle, switched to Porphyry"); 
       goto porphyry;
     } 
@@ -1727,7 +1727,7 @@ porphyry:
 	cuspsv = hsp->cusp[ih];
       }
       if (i >= niter_max) {
-	retc = ERR;
+	retc = SE_ERR;
 	strcpy(hsp->serr, "very close to polar circle, switched to Porphyry"); 
 	goto porphyry;
       }
@@ -1763,7 +1763,7 @@ porphyry:
 	cuspsv = hsp->cusp[ih];
       }
       if (i >= niter_max) {
-	retc = ERR;
+	retc = SE_ERR;
 	strcpy(hsp->serr, "very close to polar circle, switched to Porphyry"); 
 	goto porphyry;
       }
@@ -1799,7 +1799,7 @@ porphyry:
 	cuspsv = hsp->cusp[ih];
       }
       if (i >= niter_max) {
-	retc = ERR;
+	retc = SE_ERR;
 	strcpy(hsp->serr, "very close to polar circle, switched to Porphyry"); 
 	goto porphyry;
       }
@@ -1835,7 +1835,7 @@ porphyry:
 	cuspsv = hsp->cusp[ih];
       }
       if (i >= niter_max) {
-	retc = ERR;
+	retc = SE_ERR;
 	strcpy(hsp->serr, "very close to polar circle, switched to Porphyry"); 
 	goto porphyry;
       }
@@ -2164,7 +2164,7 @@ if (1) {
   		// which we do not know. If it sees ascmc[9] == 99, it uses
 		// the one is saved from last call. can lead to bugs, but can 
 		// also solve many problems.
-  if (swe_houses_armc_ex2(armc, geolat, eps, hsys, hcusp, ascmc, NULL, NULL, serr) == ERR) {
+  if (swe_houses_armc_ex2(armc, geolat, eps, hsys, hcusp, ascmc, NULL, NULL, serr) == SE_ERR) {
     if (serr != NULL)
       sprintf(serr, "swe_house_pos(): failed for system %c", hsys);
   } else {
@@ -2737,7 +2737,7 @@ if (1) {
     break;
   default:
     hpos = 0;
-    if (swe_houses_armc_ex2(armc, geolat, eps, hsys, hcusp, ascmc, NULL, NULL, serr) == ERR) {
+    if (swe_houses_armc_ex2(armc, geolat, eps, hsys, hcusp, ascmc, NULL, NULL, serr) == SE_ERR) {
       if (serr != NULL)
 	sprintf(serr, "swe_house_pos(): failed for system %c", hsys);
       break;
@@ -2802,7 +2802,7 @@ static int sunshine_init(double lat, double dec, double xh[])
   xh[11] = 1 * dsa / 3;
   xh[12] = 2 * dsa / 3;
   if (fabs(arg) >= 1)
-    return ERR;
+    return SE_ERR;
   return OK;
 }
 
@@ -2822,10 +2822,10 @@ static int sunshine_solution_makransky(double ramc, double lat, double ecl, stru
   int ih;
   // if (90 - fabs(lat) <= ecl) {
   //   strcpy(hsp->serr, "Sunshine in polar circle not allowed");
-  //   return ERR;
+  //   return SE_ERR;
   // }
-  if (sunshine_init(lat, dec, xh) == ERR)
-    return ERR;
+  if (sunshine_init(lat, dec, xh) == SE_ERR)
+    return SE_ERR;
   for (ih = 1; ih <= 12; ih++) {
     double z = 0;
     if ((ih - 1) % 3 == 0) continue;	// skip 1,4,7,10
@@ -2958,7 +2958,7 @@ static int sunshine_solution_treindl(double ramc, double lat, double ecl, struct
   double dec = hsp->sundec;
   // if (90 - fabs(lat) <= ecl) {
   //   strcpy(hsp->serr, "Sunshine in polar circle not allowed");
-  //   return ERR;
+  //   return SE_ERR;
   // }
   sinlat = sind(lat);
   coslat = cosd(lat);
@@ -2976,8 +2976,8 @@ static int sunshine_solution_treindl(double ramc, double lat, double ecl, struct
       xh[ih] = -xh[ih];
     }
   }
-  //if (sunshine_init(lat, dec, xh) == ERR)
-  //  return ERR;
+  //if (sunshine_init(lat, dec, xh) == SE_ERR)
+  //  return SE_ERR;
   // HP is the house point on the semidiurnal arc
   // CP = intersection house meridian with prime vertical
   // MP = intersection house meridian with equator
@@ -3013,7 +3013,7 @@ static int sunshine_solution_treindl(double ramc, double lat, double ecl, struct
     // now Sinussatz
     if (c < 1e-6) {
       sprintf(hsp->serr, "Sunshine house %d c=%le very small", ih, c);
-      retval = ERR;
+      retval = SE_ERR;
     }
     sinzd = sind(xhs) * sind(alpha2) / sind(c);
     zd = asind(sinzd);
diff --git a/src/libswe/swejpl.c b/src/libswe/swejpl.c
index 691aeaf..1c3b601 100644
--- a/src/libswe/swejpl.c
+++ b/src/libswe/swejpl.c
@@ -310,7 +310,7 @@ static int32 fsizer(char *serr)
     default:
       if (serr != NULL)
 	sprintf(serr,"unknown numde value %d;", numde);
-      return ERR;
+      return SE_ERR;
   }
 #endif
   if (ksize < 1000 || ksize > 5000) {
@@ -927,7 +927,7 @@ int swi_open_jpl_file(double *ss, char *fname, char *fpath, char *serr)
     ) {
     if (serr != NULL)
       strcpy(serr, "error in malloc() with JPL ephemeris.");
-    return ERR;
+    return SE_ERR;
   }
   strcpy(js->jplfname, fname);
   strcpy(js->jplfpath, fpath);
diff --git a/src/libswe/swemmoon.c b/src/libswe/swemmoon.c
index 864c442..c935a38 100644
--- a/src/libswe/swemmoon.c
+++ b/src/libswe/swemmoon.c
@@ -885,7 +885,7 @@ int swi_moshmoon(double tjd, AS_BOOL do_save, double *xpmret, char *serr)
       if (strlen(serr) + strlen(s) < AS_MAXCH)
 	strcat(serr, s);
     }
-    return(ERR);
+    return(SE_ERR);
   }  
   /* if moon has already been computed */
   if (tjd == pdp->teval && pdp->iephe == SEFLG_MOSEPH) {
@@ -1509,7 +1509,7 @@ int swi_mean_node(double J, double *pol, char *serr)
       if (strlen(serr) + strlen(s) < AS_MAXCH)
 	strcat(serr, s);
     }
-    return ERR;
+    return SE_ERR;
   }
   mean_elements();
   dcor = corr_mean_node(J) * 3600;
@@ -1582,7 +1582,7 @@ int swi_mean_apog(double J, double *pol, char *serr)
       if (strlen(serr) + strlen(s) < AS_MAXCH)
 	strcat(serr, s);
     }
-    return(ERR);
+    return(SE_ERR);
   }
   mean_elements();
   pol[0] = swi_mod2PI((SWELP - MP) * STR + PI);
diff --git a/src/libswe/swemplan.c b/src/libswe/swemplan.c
index f0ec8ef..76c987c 100644
--- a/src/libswe/swemplan.c
+++ b/src/libswe/swemplan.c
@@ -303,7 +303,7 @@ int swi_moshplan(double tjd, int ipli, AS_BOOL do_save, double *xpret, double *x
       if (strlen(serr) + strlen(s) < AS_MAXCH)
 	strcat(serr, s);
     }
-    return(ERR);
+    return(SE_ERR);
   }  
   /* earth, for geocentric position */
   if (do_earth) {
@@ -514,7 +514,7 @@ char *swi_get_fict_name(int32 ipl, char *snam)
 {
   if (read_elements_file(ipl, 0, NULL, NULL, 
        NULL, NULL, NULL, NULL, NULL, NULL, 
-       snam, NULL, NULL) == ERR)
+       snam, NULL, NULL) == SE_ERR)
     strcpy(snam, "name not found");
   return snam;
 }
@@ -593,8 +593,8 @@ int swi_osc_el_plan(double tjd, double *xp, int ipl, int ipli, double *xearth, d
    */
   if (read_elements_file(ipl, tjd, &tjd0, &tequ, 
        &mano, &sema, &ecce, &parg, &node, &incl, 
-       NULL, &fict_ifl, serr) == ERR)
-    return ERR;
+       NULL, &fict_ifl, serr) == SE_ERR)
+    return SE_ERR;
   dmot = 0.9856076686 * DEGTORAD / sema / sqrt(sema);	/* daily motion */
   if (fict_ifl & FICT_GEO)
     dmot /= sqrt(SUN_EARTH_MRAT);
@@ -709,7 +709,7 @@ static int read_elements_file(int32 ipl, double tjd,
     if (ipl >= SE_NFICT_ELEM) {
       if (serr != NULL)
         sprintf(serr, "error no elements for fictitious body no %7.0f", (double) ipl);
-      return ERR;
+      return SE_ERR;
     }
     if (tjd0 != NULL)
       *tjd0 = plan_oscu_elem[ipl][0];			/* epoch */
@@ -811,7 +811,7 @@ static int read_elements_file(int32 ipl, double tjd,
     if (mano != NULL) {
       retc = check_t_terms(tt, cpos[2], mano);
 	  *mano = swe_degnorm(*mano);
-      if (retc == ERR) {
+      if (retc == SE_ERR) {
         if (serr != NULL) {
           sprintf(serr, "%s mean anomaly value invalid", serri);
 	}
@@ -829,7 +829,7 @@ static int read_elements_file(int32 ipl, double tjd,
     /* semi-axis */
     if (sema != NULL) {
       retc = check_t_terms(tt, cpos[3], sema);
-      if (*sema <= 0 || retc == ERR) {
+      if (*sema <= 0 || retc == SE_ERR) {
         if (serr != NULL) {
           sprintf(serr, "%s semi-axis value invalid", serri);
 	}
@@ -839,7 +839,7 @@ static int read_elements_file(int32 ipl, double tjd,
     /* eccentricity */
     if (ecce != NULL) {
       retc = check_t_terms(tt, cpos[4], ecce);
-      if (*ecce >= 1 || *ecce < 0 || retc == ERR) {
+      if (*ecce >= 1 || *ecce < 0 || retc == SE_ERR) {
         if (serr != NULL) {
           sprintf(serr, "%s eccentricity invalid (no parabolic or hyperbolic orbits allowed)", serri);
 	}
@@ -850,7 +850,7 @@ static int read_elements_file(int32 ipl, double tjd,
     if (parg != NULL) {
       retc = check_t_terms(tt, cpos[5], parg);
 	  *parg = swe_degnorm(*parg);
-      if (retc == ERR) {
+      if (retc == SE_ERR) {
         if (serr != NULL) {
           sprintf(serr, "%s perihelion argument value invalid", serri);
 	}
@@ -862,7 +862,7 @@ static int read_elements_file(int32 ipl, double tjd,
     if (node != NULL) {
       retc = check_t_terms(tt, cpos[6], node);
 	  *node = swe_degnorm(*node);
-      if (retc == ERR) {
+      if (retc == SE_ERR) {
         if (serr != NULL) {
           sprintf(serr, "%s node value invalid", serri);
 	}
@@ -874,7 +874,7 @@ static int read_elements_file(int32 ipl, double tjd,
     if (incl != NULL) {
       retc = check_t_terms(tt, cpos[7], incl);
 	  *incl = swe_degnorm(*incl);
-      if (retc == ERR) {
+      if (retc == SE_ERR) {
         if (serr != NULL) {
           sprintf(serr, "%s inclination value invalid", serri);
 	}
@@ -909,7 +909,7 @@ static int read_elements_file(int32 ipl, double tjd,
   return OK;
 return_err:
   fclose(fp);
-  return ERR;
+  return SE_ERR;
 }
 #endif
 
diff --git a/src/libswe/sweodef.h b/src/libswe/sweodef.h
index 29d0c3d..24f7429 100644
--- a/src/libswe/sweodef.h
+++ b/src/libswe/sweodef.h
@@ -236,7 +236,7 @@
 
 #ifndef OK 
 #  define OK (0)
-#  define ERR (-1)
+#  define SE_ERR (-1)
 #endif
 
 /* hack because UCHAR is already used by mingw gcc */
diff --git a/src/libswe/sweph.c b/src/libswe/sweph.c
index c957fd8..931edd1 100644
--- a/src/libswe/sweph.c
+++ b/src/libswe/sweph.c
@@ -410,7 +410,7 @@ int32 CALL_CONV swe_calc(double tjd, int ipl, int32 iflag,
     use_speed3 = TRUE;
   /* topocentric with SEFLG_SPEED is not good if aberration is included. 
    * in such cases we calculate speed from three positions */
-  if ((iflag & SEFLG_SPEED) && (iflag & SEFLG_TOPOCTR) && !(iflag & SEFLG_NOABERR)) 
+  if ((iflag & SEFLG_SPEED) && (iflag & SEFLG_TOPOCTR) && !(iflag & SEFLG_NOABSE_ERR)) 
     use_speed3 = TRUE;
   /* cartesian flag excludes radians flag */
   if ((iflag & SEFLG_XYZ) && (iflag & SEFLG_RADIANS))
@@ -471,7 +471,7 @@ int32 CALL_CONV swe_calc(double tjd, int ipl, int32 iflag,
      */
     sd->tsave = tjd;
     sd->ipl = ipl;
-    if ((sd->iflgsave = swecalc(tjd, ipl, iplmoon, iflag, sd->xsaves, serr)) == ERR) 
+    if ((sd->iflgsave = swecalc(tjd, ipl, iplmoon, iflag, sd->xsaves, serr)) == SE_ERR) 
       goto return_error;
   } else {
     /* 
@@ -498,11 +498,11 @@ int32 CALL_CONV swe_calc(double tjd, int ipl, int32 iflag,
 	dt = PLAN_SPEED_INTV;
 	break;
     } 
-    if ((sd->iflgsave = swecalc(tjd-dt, ipl, iplmoon, iflag, x0, serr)) == ERR)
+    if ((sd->iflgsave = swecalc(tjd-dt, ipl, iplmoon, iflag, x0, serr)) == SE_ERR)
       goto return_error; 
-    if ((sd->iflgsave = swecalc(tjd+dt, ipl, iplmoon, iflag, x2, serr)) == ERR)
+    if ((sd->iflgsave = swecalc(tjd+dt, ipl, iplmoon, iflag, x2, serr)) == SE_ERR)
       goto return_error; 
-    if ((sd->iflgsave = swecalc(tjd, ipl, iplmoon, iflag, sd->xsaves, serr)) == ERR)
+    if ((sd->iflgsave = swecalc(tjd, ipl, iplmoon, iflag, sd->xsaves, serr)) == SE_ERR)
       goto return_error; 
     denormalize_positions(x0, sd->xsaves, x2);
     calc_speed(x0, sd->xsaves, x2, dt);
@@ -562,7 +562,7 @@ return_error:
 #ifdef TRACE
   trace_swe_calc(2, tjd, ipl, iflag, xx, serr);
 #endif
-  return ERR; 
+  return SE_ERR; 
 }
 
 int32 CALL_CONV swe_calc_ut(double tjd_ut, int32 ipl, int32 iflag, 
@@ -641,7 +641,7 @@ static int32 swecalc(double tjd, int ipl, int32 iplmoon, int32 iflag, double *x,
   if ((iflag & SEFLG_BARYCTR) && (iflag & SEFLG_MOSEPH)) {
     if (serr != NULL)
       strcpy(serr, "barycentric Moshier positions are not supported.");
-    return ERR;
+    return SE_ERR;
   }
   if (epheflag != SEFLG_MOSEPH && !swed.ephe_path_is_set && !swed.jpl_file_is_open)
     swe_set_ephe_path(NULL);
@@ -681,7 +681,7 @@ static int32 swecalc(double tjd, int ipl, int32 iplmoon, int32 iflag, double *x,
       case SEFLG_JPLEPH:
 	retc = jplplan(tjd, ipli, iflag, DO_SAVE, NULL, NULL, NULL, serr);
 	/* read error or corrupt file */
-	if (retc == ERR) 
+	if (retc == SE_ERR) 
 	  goto return_error;
         /* jpl ephemeris not on disk or date beyond ephemeris range 
 	 *     or file corrupt */
@@ -705,7 +705,7 @@ static int32 swecalc(double tjd, int ipl, int32 iplmoon, int32 iflag, double *x,
 #if 0
 	/* for hel. or bary. position, we need earth and sun as well;
          * this is done by sweplan(), but not by swemoon() */
-        if (iflag & (SEFLG_HELCTR | SEFLG_BARYCTR | SEFLG_NOABERR)) 
+        if (iflag & (SEFLG_HELCTR | SEFLG_BARYCTR | SEFLG_NOABSE_ERR)) 
 	  retc = sweplan(tjd, ipli, SEI_FILE_MOON, iflag, DO_SAVE,
 			NULL, NULL, NULL, NULL, serr);
 	else
@@ -714,7 +714,7 @@ static int32 swecalc(double tjd, int ipl, int32 iplmoon, int32 iflag, double *x,
 	retc = sweplan(tjd, ipli, SEI_FILE_MOON, iflag, DO_SAVE,
 			NULL, NULL, NULL, NULL, serr);
 #endif
-	if (retc == ERR)
+	if (retc == SE_ERR)
 	  goto return_error;
 	/* if sweph file not found, switch to moshier */
         if (retc == NOT_AVAILABLE) {
@@ -730,11 +730,11 @@ static int32 swecalc(double tjd, int ipl, int32 iplmoon, int32 iflag, double *x,
       case SEFLG_MOSEPH:
 	moshier_moon:
         retc = swi_moshmoon(tjd, DO_SAVE, NULL, serr);/**/
-	if (retc == ERR)
+	if (retc == SE_ERR)
 	  goto return_error;
 	/* for hel. position, we need earth as well */
 	retc = swi_moshplan(tjd, SEI_EARTH, DO_SAVE, NULL, NULL, serr);/**/
-	if (retc == ERR)
+	if (retc == SE_ERR)
 	  goto return_error;
 	break;
       default:
@@ -772,7 +772,7 @@ static int32 swecalc(double tjd, int ipl, int32 iplmoon, int32 iflag, double *x,
 	    goto sweph_sbar;
 	}
 	retc = swi_pleph(tjd, J_SUN, J_SBARY, psdp->x, serr);
-	if (retc == ERR || retc == BEYOND_EPH_LIMITS) {
+	if (retc == SE_ERR || retc == BEYOND_EPH_LIMITS) {
 	  swi_close_jpl_file();
 	  swed.jpl_file_is_open = FALSE;
 	  goto return_error;
@@ -793,11 +793,11 @@ static int32 swecalc(double tjd, int ipl, int32 iplmoon, int32 iflag, double *x,
 	 * it is saved in swed.pldat[SEI_SUNBARY].x */
 	retc = sweplan(tjd, SEI_EARTH, SEI_FILE_PLANET, iflag, DO_SAVE, NULL, NULL, NULL, NULL, serr);
 #if 1
-	if (retc == ERR || retc == NOT_AVAILABLE)
+	if (retc == SE_ERR || retc == NOT_AVAILABLE)
 	  goto return_error;
 #else	/* this code would be needed if barycentric moshier calculation
 	 * were implemented */
-	if (retc == ERR)
+	if (retc == SE_ERR)
 	  goto return_error;
 	/* if sweph file not found, switch to moshier */
         if (retc == NOT_AVAILABLE) {
@@ -817,7 +817,7 @@ static int32 swecalc(double tjd, int ipl, int32 iplmoon, int32 iflag, double *x,
 #if 0
 	moshier_sbar:
 #endif
-	return ERR;
+	return SE_ERR;
 	break;
     }
     /* flags */
@@ -868,7 +868,7 @@ static int32 swecalc(double tjd, int ipl, int32 iplmoon, int32 iflag, double *x,
     pdp = &swed.pldat[ipli];
     xp = pdp->xreturn;
     retc = main_planet(tjd, ipli, iplmoon, epheflag, iflag, serr);
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
     /* iflag has possibly changed in main_planet() */
     iflag = pdp->xflgs;
@@ -887,11 +887,11 @@ static int32 swecalc(double tjd, int ipl, int32 iplmoon, int32 iflag, double *x,
     xp = ndp->xreturn;
     xp2 = ndp->x;
     retc = swi_mean_node(tjd, xp2, serr);
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
     /* speed (is almost constant; variation < 0.001 arcsec) */
     retc = swi_mean_node(tjd - MEAN_NODE_SPEED_INTV, xp2+3, serr);
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
     xp2[3] = swe_difrad2n(xp2[0], xp2[3]) / MEAN_NODE_SPEED_INTV;
     xp2[4] = xp2[5] = 0;
@@ -909,7 +909,7 @@ static int32 swecalc(double tjd, int ipl, int32 iplmoon, int32 iflag, double *x,
       ndp->xreturn[8] = 0.0;	/* z coordinate        */
       ndp->xreturn[11] = 0.0;	/*               speed */
     }
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
   /********************************************** 
    * mean lunar apogee ('dark moon', 'lilith')  *
@@ -926,11 +926,11 @@ static int32 swecalc(double tjd, int ipl, int32 iplmoon, int32 iflag, double *x,
     xp = ndp->xreturn;
     xp2 = ndp->x;
     retc = swi_mean_apog(tjd, xp2, serr);
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
     /* speed (is not constant! variation ~= several arcsec) */
     retc = swi_mean_apog(tjd - MEAN_NODE_SPEED_INTV, xp2+3, serr);
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
     for(i = 0; i <= 1; i++)
       xp2[3+i] = swe_difrad2n(xp2[i], xp2[3+i]) / MEAN_NODE_SPEED_INTV;
@@ -943,7 +943,7 @@ static int32 swecalc(double tjd, int ipl, int32 iplmoon, int32 iflag, double *x,
     /* to avoid infinitesimal deviations from r-speed = 0 
      * that result from conversions */
     ndp->xreturn[5] = 0.0;	/*               speed */
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
   /*********************************************** 
    * osculating lunar node ('true node')         *    
@@ -967,7 +967,7 @@ static int32 swecalc(double tjd, int ipl, int32 iplmoon, int32 iflag, double *x,
       ndp->xreturn[8] = 0.0;	/* z coordinate        */
       ndp->xreturn[11] = 0.0;	/*               speed */
     }
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
   /*********************************************** 
    * osculating lunar apogee                     *    
@@ -983,7 +983,7 @@ static int32 swecalc(double tjd, int ipl, int32 iplmoon, int32 iflag, double *x,
     xp = ndp->xreturn;
     retc = lunar_osc_elem(tjd, SEI_OSCU_APOG, iflag, serr); 
     iflag = ndp->xflgs;
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
   /*********************************************** 
    * interpolated lunar apogee                   *    
@@ -1001,13 +1001,13 @@ static int32 swecalc(double tjd, int ipl, int32 iplmoon, int32 iflag, double *x,
       if (serr != NULL)
 	sprintf(serr, "Interpolated apsides are restricted to JD %8.1f - JD %8.1f",
 		MOSHLUEPH_START, MOSHLUEPH_END);
-      return ERR;
+      return SE_ERR;
     }
     ndp = &swed.nddat[SEI_INTP_APOG];
     xp = ndp->xreturn;
     retc = intp_apsides(tjd, SEI_INTP_APOG, iflag, serr); 
     iflag = ndp->xflgs;
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
   /*********************************************** 
    * interpolated lunar perigee                  *    
@@ -1025,13 +1025,13 @@ static int32 swecalc(double tjd, int ipl, int32 iplmoon, int32 iflag, double *x,
       if (serr != NULL)
 	sprintf(serr, "Interpolated apsides are restricted to JD %8.1f - JD %8.1f",
 		MOSHLUEPH_START, MOSHLUEPH_END);
-      return ERR;
+      return SE_ERR;
     }
     ndp = &swed.nddat[SEI_INTP_PERG];
     xp = ndp->xreturn;
     retc = intp_apsides(tjd, SEI_INTP_PERG, iflag, serr); 
     iflag = ndp->xflgs;
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
   /*********************************************** 
    * minor planets                               *    
@@ -1078,19 +1078,19 @@ static int32 swecalc(double tjd, int ipl, int32 iplmoon, int32 iflag, double *x,
       if (serr != NULL)
 	sprintf(serr, "Chiron's ephemeris is restricted to JD %8.1f - JD %8.1f",
 		CHIRON_START, CHIRON_END);
-      return ERR;
+      return SE_ERR;
     }
     if (ipli == SEI_PHOLUS && (tjd < PHOLUS_START || tjd > PHOLUS_END)) {
       if (serr != NULL)
 	sprintf(serr, 
 		"Pholus's ephemeris is restricted to JD %8.1f - JD %8.1f",
 		PHOLUS_START, PHOLUS_END);
-      return ERR;
+      return SE_ERR;
     }
   do_asteroid:
     /* earth and sun are also needed */
     retc = main_planet(tjd, SEI_EARTH, 0, epheflag, iflag, serr);
-    if (retc == ERR) 
+    if (retc == SE_ERR) 
       goto return_error;
     /* iflag (ephemeris bit) has possibly changed in main_planet() */
     iflag = swed.pldat[SEI_EARTH].xflgs;
@@ -1101,10 +1101,10 @@ static int32 swecalc(double tjd, int ipl, int32 iplmoon, int32 iflag, double *x,
     }
     /* asteroid */
     retc = sweph(tjd, ipli_ast, ifno, iflag, psdp->x, DO_SAVE, NULL, serr);
-    if (retc == ERR || retc == NOT_AVAILABLE) 
+    if (retc == SE_ERR || retc == NOT_AVAILABLE) 
       goto return_error;
     retc = app_pos_etc_plan(ipli_ast, 0, iflag, serr);
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
     /* app_pos_etc_plan() might have failed, if t(light-time)
      * is beyond ephemeris range. in this case redo with Moshier 
@@ -1140,7 +1140,7 @@ static int32 swecalc(double tjd, int ipl, int32 iplmoon, int32 iflag, double *x,
     || ipl == SE_VULKANUS
     || ipl == SE_POSEIDON
     || ipl == SE_ISIS
-    || ipl == SE_NEPTUNE_LEVERRIER
+    || ipl == SE_NEPTUNE_LEVSE_ERRIER
     || ipl == SE_NEPTUNE_ADAMS) 
 #endif
     /* internal planet number */
@@ -1155,10 +1155,10 @@ static int32 swecalc(double tjd, int ipl, int32 iplmoon, int32 iflag, double *x,
     /* planet from osculating elements */
     if (swi_osc_el_plan(tjd, pdp->x, ipl-SE_FICT_OFFSET, ipli, pedp->x, psdp->x, serr) != OK)
       goto return_error;
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
     retc = app_pos_etc_plan_osc(ipl, ipli, iflag, serr);
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
     /* app_pos_etc_plan_osc() might have failed, if t(light-time)
      * is beyond ephemeris range. in this case redo with Moshier 
@@ -1191,7 +1191,7 @@ static int32 swecalc(double tjd, int ipl, int32 iplmoon, int32 iflag, double *x,
   return_error:;
   for (i = 0; i < 24; i++)
     x[i] = 0;
-  return ERR;
+  return SE_ERR;
 }
 
 static void free_planets(void)
@@ -1438,15 +1438,15 @@ void load_dpsi_deps(void)
     return;
   fp = swi_fopen(-1, DPSI_DEPS_IAU1980_FILE_EOPC04, swed.ephepath, NULL);
   if (fp == NULL) {
-    swed.eop_dpsi_loaded = ERR;
+    swed.eop_dpsi_loaded = SE_ERR;
     return;
   }
   if ((swed.dpsi = (double *) calloc((size_t) SWE_DATA_DPSI_DEPS, sizeof(double))) == NULL) {
-    swed.eop_dpsi_loaded = ERR;
+    swed.eop_dpsi_loaded = SE_ERR;
     return;
   }
   if ((swed.deps = (double *) calloc((size_t) SWE_DATA_DPSI_DEPS, sizeof(double))) == NULL) {
-    swed.eop_dpsi_loaded = ERR;
+    swed.eop_dpsi_loaded = SE_ERR;
     return;
   }
   swed.eop_tjd_beg_horizons = DPSI_DEPS_IAU1980_TJD0_HORIZONS;
@@ -1611,15 +1611,15 @@ static int main_planet(double tjd, int ipli, int iplmoon, int32 epheflag, int32
     //ipli_com = ipli * 100 + 9099;
     /* jupiter center of body, relative to jupiter barycenter */
     retc = sweph(tjd, iplmoon, SEI_FILE_ANY_AST, iflag, NULL, DO_SAVE, NULL, serr);
-    if (retc == ERR || retc == NOT_AVAILABLE) 
-      return ERR;
+    if (retc == SE_ERR || retc == NOT_AVAILABLE) 
+      return SE_ERR;
   }
   switch(epheflag) {
     case SEFLG_JPLEPH:
       retc = jplplan(tjd, ipli, iflag, DO_SAVE, NULL, NULL, NULL, serr);
       /* read error or corrupt file */
-      if (retc == ERR) 
-	return ERR;
+      if (retc == SE_ERR) 
+	return SE_ERR;
       /* jpl ephemeris not on disk or date beyond ephemeris range */
       if (retc == NOT_AVAILABLE) {
 	iflag = (iflag & ~SEFLG_JPLEPH) | SEFLG_SWIEPH;
@@ -1633,7 +1633,7 @@ static int main_planet(double tjd, int ipli, int iplmoon, int32 epheflag, int32
 	    strcat(serr, " \nusing Moshier Eph; ");
 	  goto moshier_planet;
 	} else {
-	  return ERR;
+	  return SE_ERR;
 	}
       }
       /* geocentric, lighttime etc. */
@@ -1642,8 +1642,8 @@ static int main_planet(double tjd, int ipli, int iplmoon, int32 epheflag, int32
       } else {
 	retc = app_pos_etc_plan(ipli, iplmoon, iflag, serr);
       }
-      if (retc == ERR)
-	return ERR;
+      if (retc == SE_ERR)
+	return SE_ERR;
       /* t for light-time beyond ephemeris range */
       if (retc == NOT_AVAILABLE) {
 	iflag = (iflag & ~SEFLG_JPLEPH) | SEFLG_SWIEPH;
@@ -1657,15 +1657,15 @@ static int main_planet(double tjd, int ipli, int iplmoon, int32 epheflag, int32
 	    strcat(serr, " \nusing Moshier Eph; ");
 	  goto moshier_planet;
 	} else
-	  return ERR;
+	  return SE_ERR;
       }
       break;
     case SEFLG_SWIEPH:
       sweph_planet:
       /* compute barycentric planet (+ earth, sun, moon) */
       retc = sweplan(tjd, ipli, SEI_FILE_PLANET, iflag, DO_SAVE, NULL, NULL, NULL, NULL, serr);
-      if (retc == ERR)
-	return ERR;
+      if (retc == SE_ERR)
+	return SE_ERR;
       /* if sweph file not found, switch to moshier */
       if (retc == NOT_AVAILABLE) {
 	if (tjd > MOSHPLEPH_START && tjd < MOSHPLEPH_END) {
@@ -1674,15 +1674,15 @@ static int main_planet(double tjd, int ipli, int iplmoon, int32 epheflag, int32
 	    strcat(serr, " \nusing Moshier eph.; ");
 	  goto moshier_planet;
 	} else 
-	  return ERR;
+	  return SE_ERR;
       }
       /* geocentric, lighttime etc. */
       if (ipli == SEI_SUN)
 	retc = app_pos_etc_sun(iflag, serr)/**/;
       else
 	retc = app_pos_etc_plan(ipli, iplmoon, iflag, serr);
-      if (retc == ERR)
-	return ERR;
+      if (retc == SE_ERR)
+	return SE_ERR;
       /* if sweph file for t(lighttime) not found, switch to moshier */
       if (retc == NOT_AVAILABLE) {
 	if (tjd > MOSHPLEPH_START && tjd < MOSHPLEPH_END) {
@@ -1691,21 +1691,21 @@ static int main_planet(double tjd, int ipli, int iplmoon, int32 epheflag, int32
 	    strcat(serr, " \nusing Moshier eph.; ");
 	  goto moshier_planet;
 	} else
-	  return ERR;
+	  return SE_ERR;
       }
       break;
     case SEFLG_MOSEPH:
       moshier_planet:
       retc = swi_moshplan(tjd, ipli, DO_SAVE, NULL, NULL, serr);/**/
-      if (retc == ERR)
-	return ERR;
+      if (retc == SE_ERR)
+	return SE_ERR;
       /* geocentric, lighttime etc. */
       if (ipli == SEI_SUN)
 	retc = app_pos_etc_sun(iflag, serr)/**/;
       else
 	retc = app_pos_etc_plan(ipli, iplmoon, iflag, serr);
-      if (retc == ERR)
-	return ERR;
+      if (retc == SE_ERR)
+	return SE_ERR;
       break;
     default:
       break;
@@ -1744,7 +1744,7 @@ static int main_planet_bary(double tjd, int ipli, int32 epheflag, int32 iflag, A
     case SEFLG_JPLEPH:
       retc = jplplan(tjd, ipli, iflag, do_save, xp, xe, xs, serr);
       /* read error or corrupt file */
-      if (retc == ERR || retc == BEYOND_EPH_LIMITS) 
+      if (retc == SE_ERR || retc == BEYOND_EPH_LIMITS) 
 	return retc;
       /* jpl ephemeris not on disk or date beyond ephemeris range */
       if (retc == NOT_AVAILABLE) {
@@ -1759,11 +1759,11 @@ static int main_planet_bary(double tjd, int ipli, int32 epheflag, int32 iflag, A
       /* compute barycentric planet (+ earth, sun, moon) */
       retc = sweplan(tjd, ipli, SEI_FILE_PLANET, iflag, do_save, xp, xe, xs, xm, serr);
 #if 0
-      if (retc == ERR || retc == NOT_AVAILABLE)
+      if (retc == SE_ERR || retc == NOT_AVAILABLE)
 	return retc;
 #else /* if barycentric moshier calculation were implemented */
-      if (retc == ERR)
-	return ERR;
+      if (retc == SE_ERR)
+	return SE_ERR;
       /* if sweph file not found, switch to moshier */
       if (retc == NOT_AVAILABLE) {
 	if (tjd > MOSHPLEPH_START && tjd < MOSHPLEPH_END) {
@@ -1772,7 +1772,7 @@ static int main_planet_bary(double tjd, int ipli, int32 epheflag, int32 iflag, A
 	    strcat(serr, " \nusing Moshier eph.; ");
 	  goto moshier_planet;
 	} else {
-	  return ERR;
+	  return SE_ERR;
 	}
       }
 #endif
@@ -1782,8 +1782,8 @@ static int main_planet_bary(double tjd, int ipli, int32 epheflag, int32 iflag, A
       moshier_planet:
 #endif
       retc = swi_moshplan(tjd, ipli, do_save, xp, xe, serr);/**/
-      if (retc == ERR)
-	return ERR;
+      if (retc == SE_ERR)
+	return SE_ERR;
       for (i = 0; i <= 5; i++)
 	xs[i] = 0;
       break;
@@ -1887,9 +1887,9 @@ static int sweplan(double tjd, int ipli, int ifno, int32 iflag, AS_BOOL do_save,
     do_earth = TRUE;
   if (ipli == SEI_MOON) { 
 #if 0
-  if (iflag & (SEFLG_HELCTR | SEFLG_BARYCTR | SEFLG_NOABERR)) 
+  if (iflag & (SEFLG_HELCTR | SEFLG_BARYCTR | SEFLG_NOABSE_ERR)) 
       do_earth = TRUE;
-  if (iflag & (SEFLG_HELCTR | SEFLG_NOABERR))
+  if (iflag & (SEFLG_HELCTR | SEFLG_NOABSE_ERR))
       do_sunbary = TRUE;
 #else
     do_earth = TRUE;
@@ -1939,7 +1939,7 @@ static int sweplan(double tjd, int ipli, int ifno, int32 iflag, AS_BOOL do_save,
 	xpm[i] = pmdp->x[i];
     } else {
       retc = sweph(tjd, SEI_MOON, SEI_FILE_MOON, iflag, NULL, do_save, xpm, serr);
-      if (retc == ERR) 
+      if (retc == SE_ERR) 
 	return(retc);
       /* if moon file doesn't exist, take moshier moon */
       if (swed.fidat[SEI_FILE_MOON].fptr == NULL) {
@@ -2069,10 +2069,10 @@ static int jplplan(double tjd, int ipli, int32 iflag, AS_BOOL do_save,
     xps = xxs;
   }
   if (do_save || ipli == SEI_EARTH || xperet != NULL 
-    || (ipli == SEI_MOON)) /* && (iflag & (SEFLG_HELCTR | SEFLG_BARYCTR | SEFLG_NOABERR)))) */
+    || (ipli == SEI_MOON)) /* && (iflag & (SEFLG_HELCTR | SEFLG_BARYCTR | SEFLG_NOABSE_ERR)))) */
     do_earth = TRUE;
   if (do_save || ipli == SEI_SUNBARY || xpsret != NULL 
-    || (ipli == SEI_MOON)) /* && (iflag & (SEFLG_HELCTR | SEFLG_NOABERR)))) */
+    || (ipli == SEI_MOON)) /* && (iflag & (SEFLG_HELCTR | SEFLG_NOABSE_ERR)))) */
     do_sunbary = TRUE;
   if (ipli == SEI_MOON)
     ictr = J_EARTH;
@@ -2578,7 +2578,7 @@ static int app_pos_etc_plan(int ipli, int iplmoon, int32 iflag, char *serr)
     if (swed.topd.teval != pedp->teval
       || swed.topd.teval == 0) {
       if (swi_get_observer(pedp->teval, iflag | SEFLG_NONUT, DO_SAVE, xobs, serr) != OK)
-        return ERR;
+        return SE_ERR;
     } else {
       for (i = 0; i <= 5; i++)
         xobs[i] = swed.topd.xobs[i];
@@ -2658,8 +2658,8 @@ static int app_pos_etc_plan(int ipli, int iplmoon, int32 iflag, char *serr)
       //ipli_com = ipli * 100 + 9099;
       /* jupiter center of body, relative to jupiter barycenter */
       retc = sweph(t, iplmoon, SEI_FILE_ANY_AST, iflag, NULL, NO_SAVE, xcom, serr);
-      if (retc == ERR || retc == NOT_AVAILABLE)
-	return ERR;
+      if (retc == SE_ERR || retc == NOT_AVAILABLE)
+	return SE_ERR;
     }
     switch(epheflag) {
       case SEFLG_JPLEPH:
@@ -2755,7 +2755,7 @@ static int app_pos_etc_plan(int ipli, int iplmoon, int32 iflag, char *serr)
       /* observer position for t(light-time) */
       if (iflag & SEFLG_TOPOCTR) {
         if (swi_get_observer(t, iflag | SEFLG_NONUT, NO_SAVE, xobs2, serr) != OK)
-          return ERR;
+          return SE_ERR;
         for (i = 0; i <= 5; i++)
           xobs2[i] += xearth[i];
       } else {
@@ -2802,8 +2802,8 @@ static int app_pos_etc_plan(int ipli, int iplmoon, int32 iflag, char *serr)
   /**********************************
    * 'annual' aberration of light   *
    **********************************/
-  if (!(iflag & SEFLG_TRUEPOS) && !(iflag & SEFLG_NOABERR)) {
-		/* SEFLG_NOABERR is on, if SEFLG_HELCTR or SEFLG_BARYCTR */
+  if (!(iflag & SEFLG_TRUEPOS) && !(iflag & SEFLG_NOABSE_ERR)) {
+		/* SEFLG_NOABSE_ERR is on, if SEFLG_HELCTR or SEFLG_BARYCTR */
     swi_aberr_light(xx, xobs, iflag);
     /* 
      * Apparent speed is also influenced by
@@ -2882,11 +2882,11 @@ static int app_pos_rest(struct plan_data *pdp, int32 iflag,
     /* project onto ecliptic t0 */
     if (swed.sidd.sid_mode & SE_SIDBIT_ECL_T0) {
       if (swi_trop_ra2sid_lon(x2000, pdp->xreturn+6, pdp->xreturn+18, iflag) != OK)
-	return ERR;
+	return SE_ERR;
     /* project onto solar system equator */
     } else if (swed.sidd.sid_mode & SE_SIDBIT_SSY_PLANE) {
       if (swi_trop_ra2sid_lon_sosy(x2000, pdp->xreturn+6, iflag) != OK)
-	return ERR;
+	return SE_ERR;
     } else {
     /* traditional algorithm */
       swi_cartpol_sp(pdp->xreturn+6, pdp->xreturn); 
@@ -2895,8 +2895,8 @@ static int app_pos_rest(struct plan_data *pdp, int32 iflag,
        * Therefore current values are saved... */
       for (i = 0; i < 24; i++)
         xxsv[i] = pdp->xreturn[i];
-      if (swi_get_ayanamsa_with_speed(pdp->teval, iflag, daya, serr) == ERR)
-        return ERR;
+      if (swi_get_ayanamsa_with_speed(pdp->teval, iflag, daya, serr) == SE_ERR)
+        return SE_ERR;
       /* ... and restored */
       for (i = 0; i < 24; i++)
         pdp->xreturn[i] = xxsv[i];
@@ -3090,7 +3090,7 @@ int32 swi_get_ayanamsa_ex(double tjd_et, int32 iflag, double *daya, char *serr)
    * provided */
   iflag_true = iflag;
   if (otherflag & SEFLG_TRUEPOS) iflag_true |= SEFLG_TRUEPOS;
-  if (otherflag & SEFLG_NOABERR) iflag_true |= SEFLG_NOABERR;
+  if (otherflag & SEFLG_NOABSE_ERR) iflag_true |= SEFLG_NOABSE_ERR;
   if (otherflag & SEFLG_NOGDEFL) iflag_true |= SEFLG_NOGDEFL;
 #endif
   /* warning, if swe_set_ephe_path() or swe_set_jplfile() was not called yet,
@@ -3115,8 +3115,8 @@ int32 swi_get_ayanamsa_ex(double tjd_et, int32 iflag, double *daya, char *serr)
     swe_set_sid_mode(SE_SIDM_FAGAN_BRADLEY, 0, 0);
   if (sid_mode == SE_SIDM_TRUE_CITRA) {
     strcpy(star, "Spica"); /* Citra */
-    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == ERR) {
-      return ERR; 
+    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == SE_ERR) {
+      return SE_ERR; 
     }
     /*fprintf(stderr, "serr=%s\n", serr);*/
     *daya = swe_degnorm(x[0] - 180);
@@ -3124,52 +3124,52 @@ int32 swi_get_ayanamsa_ex(double tjd_et, int32 iflag, double *daya, char *serr)
   }
   if (sid_mode == SE_SIDM_TRUE_REVATI) {
     strcpy(star, ",zePsc"); /* Revati */
-    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == ERR)
-      return ERR;
+    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == SE_ERR)
+      return SE_ERR;
     *daya = swe_degnorm(x[0] - 359.8333333333);
     return (retflag & SEFLG_EPHMASK);
   }
   if (sid_mode == SE_SIDM_TRUE_PUSHYA) {
     strcpy(star, ",deCnc"); /* Pushya = Asellus Australis */
-    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == ERR)
-      return ERR;
+    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == SE_ERR)
+      return SE_ERR;
     *daya = swe_degnorm(x[0] - 106);
     return (retflag & SEFLG_EPHMASK);
   }
   if (sid_mode == SE_SIDM_TRUE_SHEORAN) {
     strcpy(star, ",deCnc"); /* Asellus Australis */
-    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == ERR)
-      return ERR;
+    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == SE_ERR)
+      return SE_ERR;
     *daya = swe_degnorm(x[0] - 103.49264221625);
     return (retflag & SEFLG_EPHMASK);
   }
   if (sid_mode == SE_SIDM_TRUE_MULA) {
     strcpy(star, ",laSco"); /* Mula = lambda Scorpionis */
-    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == ERR)
-      return ERR;
+    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == SE_ERR)
+      return SE_ERR;
     *daya = swe_degnorm(x[0] - 240);
     return (retflag & SEFLG_EPHMASK);
   }
   if (sid_mode ==  SE_SIDM_GALCENT_0SAG) {
     strcpy(star, ",SgrA*"); /* Galactic Centre */
-    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == ERR)
-      return ERR;
+    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == SE_ERR)
+      return SE_ERR;
     *daya = swe_degnorm(x[0] - 240.0);
     return (retflag & SEFLG_EPHMASK);
     /*return swe_degnorm(x[0] - 359.83333333334);*/
   }
   if (sid_mode ==  SE_SIDM_GALCENT_COCHRANE) {
     strcpy(star, ",SgrA*"); /* Galactic Centre */
-    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == ERR)
-      return ERR;
+    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == SE_ERR)
+      return SE_ERR;
     *daya = swe_degnorm(x[0] - 270.0);
     return (retflag & SEFLG_EPHMASK);
     /*return swe_degnorm(x[0] - 359.83333333334);*/
   }
   if (sid_mode ==  SE_SIDM_GALCENT_RGILBRAND) {
     strcpy(star, ",SgrA*"); /* Galactic Centre */
-    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == ERR)
-      return ERR;
+    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == SE_ERR)
+      return SE_ERR;
     *daya = swe_degnorm(x[0] - 210.0 - 90.0 * 0.3819660113);
     return (retflag & SEFLG_EPHMASK);
     /*return swe_degnorm(x[0] - 359.83333333334);*/
@@ -3178,8 +3178,8 @@ int32 swi_get_ayanamsa_ex(double tjd_et, int32 iflag, double *daya, char *serr)
     strcpy(star, ",SgrA*"); /* Galactic Centre */
     /* right ascension in polar projection onto the ecliptic, 
      * and that point is put in the middle of Mula */
-    if ((retflag = swe_fixstar(star, tjd_et, iflag_true | SEFLG_EQUATORIAL, x, serr)) == ERR)
-      return ERR;
+    if ((retflag = swe_fixstar(star, tjd_et, iflag_true | SEFLG_EQUATORIAL, x, serr)) == SE_ERR)
+      return SE_ERR;
     eps = swi_epsiln(tjd_et, iflag) * RADTODEG;
     *daya = swi_armc_to_mc(x[0], eps);
     *daya = swe_degnorm(*daya - 246.6666666667);
@@ -3188,22 +3188,22 @@ int32 swi_get_ayanamsa_ex(double tjd_et, int32 iflag, double *daya, char *serr)
   }
   if (sid_mode == SE_SIDM_GALEQU_IAU1958) {
     strcpy(star, ",GP1958"); /* Galactic Pole IAU 1958 */
-    if ((retflag = swe_fixstar(star, tjd_et, iflag_galequ, x, serr)) == ERR)
-      return ERR;
+    if ((retflag = swe_fixstar(star, tjd_et, iflag_galequ, x, serr)) == SE_ERR)
+      return SE_ERR;
     *daya = swe_degnorm(x[0] - 150);
     return (retflag & SEFLG_EPHMASK);
   }
   if (sid_mode == SE_SIDM_GALEQU_TRUE) {
     strcpy(star, ",GPol"); /* Galactic Pole modern, true */
-    if ((retflag = swe_fixstar(star, tjd_et, iflag_galequ, x, serr)) == ERR)
-      return ERR;
+    if ((retflag = swe_fixstar(star, tjd_et, iflag_galequ, x, serr)) == SE_ERR)
+      return SE_ERR;
     *daya = swe_degnorm(x[0] - 150);
     return (retflag & SEFLG_EPHMASK);
   }
   if (sid_mode == SE_SIDM_GALEQU_MULA) {
     strcpy(star, ",GPol"); /* Galactic Pole modern, true */
-    if ((retflag = swe_fixstar(star, tjd_et, iflag_galequ, x, serr)) == ERR)
-      return ERR;
+    if ((retflag = swe_fixstar(star, tjd_et, iflag_galequ, x, serr)) == SE_ERR)
+      return SE_ERR;
     *daya = swe_degnorm(x[0] - 150 - 6.6666666667);
     return (retflag & SEFLG_EPHMASK);
   }
@@ -3281,11 +3281,11 @@ int32 swi_get_ayanamsa_with_speed(double tjd_et, int32 iflag, double *daya, char
   int32 retflag;
   t2 = tjd_et - tintv;
   retflag = swi_get_ayanamsa_ex(t2, iflag, &daya_t2, serr);
-  if (retflag == ERR) 
-    return ERR;
+  if (retflag == SE_ERR) 
+    return SE_ERR;
   retflag = swi_get_ayanamsa_ex(tjd_et, iflag, daya, serr);
-  if (retflag == ERR) 
-    return ERR;
+  if (retflag == SE_ERR) 
+    return SE_ERR;
   daya[1] = (daya[0] - daya_t2) / tintv;
   return retflag;
 }
@@ -3463,7 +3463,7 @@ static int app_pos_etc_plan_osc(int ipl, int ipli, int32 iflag, char *serr)
     if (swed.topd.teval != pedp->teval
       || swed.topd.teval == 0) {
       if (swi_get_observer(pedp->teval, iflag | SEFLG_NONUT, DO_SAVE, xobs, serr) != OK)
-        return ERR;
+        return SE_ERR;
     } else {
       for (i = 0; i <= 5; i++)
         xobs[i] = swed.topd.xobs[i];
@@ -3543,12 +3543,12 @@ static int app_pos_etc_plan_osc(int ipl, int ipli, int32 iflag, char *serr)
       /* for accuracy in speed, we will need earth as well */
       retc = main_planet_bary(t, SEI_EARTH, epheflag, iflag, NO_SAVE, xearth, xearth, xsun, xmoon, serr);
       if (swi_osc_el_plan(t, xx, ipl-SE_FICT_OFFSET, ipli, xearth, xsun, serr) != OK)
-	return ERR;
+	return SE_ERR;
       if (retc != OK)
 	return(retc);
       if (iflag & SEFLG_TOPOCTR) {
         if (swi_get_observer(t, iflag | SEFLG_NONUT, NO_SAVE, xobs2, serr) != OK)
-          return ERR;
+          return SE_ERR;
         for (i = 0; i <= 5; i++)
           xobs2[i] += xearth[i];
       } else {
@@ -3584,8 +3584,8 @@ static int app_pos_etc_plan_osc(int ipl, int ipli, int32 iflag, char *serr)
   /**********************************
    * 'annual' aberration of light   *
    **********************************/
-  if (!(iflag & SEFLG_TRUEPOS) && !(iflag & SEFLG_NOABERR)) {
-		/* SEFLG_NOABERR is on, if SEFLG_HELCTR or SEFLG_BARYCTR */
+  if (!(iflag & SEFLG_TRUEPOS) && !(iflag & SEFLG_NOABSE_ERR)) {
+		/* SEFLG_NOABSE_ERR is on, if SEFLG_HELCTR or SEFLG_BARYCTR */
     swi_aberr_light(xx, xobs, iflag);
     /* 
      * Apparent speed is also influenced by
@@ -3985,7 +3985,7 @@ static int app_pos_etc_sun(int32 iflag, char *serr)
     if (swed.topd.teval != pedp->teval
       || swed.topd.teval == 0) {
       if (swi_get_observer(pedp->teval, iflag | SEFLG_NONUT, DO_SAVE, xobs, serr) != OK)
-        return ERR;
+        return SE_ERR;
     } else {
       for (i = 0; i <= 5; i++)
         xobs[i] = swed.topd.xobs[i];
@@ -4074,7 +4074,7 @@ static int app_pos_etc_sun(int32 iflag, char *serr)
 	    /* with moshier there is no barycentric sun */
 	    break;
           default:
-	    retc = ERR;
+	    retc = SE_ERR;
 	    break;
 	} 
 	if (retc != OK)
@@ -4100,8 +4100,8 @@ static int app_pos_etc_sun(int32 iflag, char *serr)
   /**********************************
    * 'annual' aberration of light   *
    **********************************/
-  if (!(iflag & SEFLG_TRUEPOS) && !(iflag & SEFLG_NOABERR)) {
-		/* SEFLG_NOABERR is on, if SEFLG_HELCTR or SEFLG_BARYCTR */
+  if (!(iflag & SEFLG_TRUEPOS) && !(iflag & SEFLG_NOABSE_ERR)) {
+		/* SEFLG_NOABSE_ERR is on, if SEFLG_HELCTR or SEFLG_BARYCTR */
     swi_aberr_light(xx, xobs, iflag);
   }
   if (!(iflag & SEFLG_SPEED))
@@ -4138,7 +4138,7 @@ static int app_pos_etc_sun(int32 iflag, char *serr)
  * note: 
  * for apparent positions, we consider the earth-moon
  * system as independant.
- * for astrometric positions (SEFLG_NOABERR), we 
+ * for astrometric positions (SEFLG_NOABSE_ERR), we 
  * consider the motions of the earth and the moon 
  * related to the solar system barycenter.
  */
@@ -4179,7 +4179,7 @@ static int app_pos_etc_moon(int32 iflag, char *serr)
     if (swed.topd.teval != pdp->teval
       || swed.topd.teval == 0) {
       if (swi_get_observer(pdp->teval, iflag | SEFLG_NONUT, DO_SAVE, xobs, serr) != OK)
-        return ERR;
+        return SE_ERR;
     } else {
       for (i = 0; i <= 5; i++)
         xobs[i] = swed.topd.xobs[i];
@@ -4243,7 +4243,7 @@ static int app_pos_etc_moon(int32 iflag, char *serr)
     } 
     if (iflag & SEFLG_TOPOCTR) {
       if (swi_get_observer(t, iflag | SEFLG_NONUT, NO_SAVE, xobs2, NULL) != OK)
-	  return ERR;
+	  return SE_ERR;
       for (i = 0; i <= 5; i++)
 	xobs2[i] += xe[i];
     } else if (iflag & SEFLG_BARYCTR) {
@@ -4265,8 +4265,8 @@ static int app_pos_etc_moon(int32 iflag, char *serr)
   /**********************************
    * 'annual' aberration of light   *
    **********************************/
-  if (!(iflag & SEFLG_TRUEPOS) && !(iflag & SEFLG_NOABERR)) {
-		/* SEFLG_NOABERR is on, if SEFLG_HELCTR or SEFLG_BARYCTR */
+  if (!(iflag & SEFLG_TRUEPOS) && !(iflag & SEFLG_NOABSE_ERR)) {
+		/* SEFLG_NOABSE_ERR is on, if SEFLG_HELCTR or SEFLG_BARYCTR */
     swi_aberr_light(xx, xobs, iflag);
     /* 
      * Apparent speed is also influenced by
@@ -4506,7 +4506,7 @@ static int get_new_segment(double tjd, int ipli, int ifno, char *serr)
       }
       free(pdp->segp);
       pdp->segp = NULL;
-      return (ERR);
+      return (SE_ERR);
     }
     /* now unpack */
     for (i = 0; i < nsizes; i++) {
@@ -4578,7 +4578,7 @@ return_error_gns:
   // free(fdp->fptr);  is not from malloc(), must not be freed by us
   fdp->fptr = NULL;
   free_planets();
-  return ERR;
+  return SE_ERR;
 }
 
 /* SWISSEPH
@@ -4977,7 +4977,7 @@ return_error:
   // free(fdp->fptr);  is not from malloc(), must not be freed by us
   fdp->fptr = NULL;
   free_planets();
-  return(ERR);
+  return(SE_ERR);
 }
 
 /* SWISSEPH
@@ -5012,7 +5012,7 @@ static int do_fread(void *trg, int size, int count, int corrsize, FILE *fp, int3
 	  sprintf(serr, "Ephemeris file %s is damaged (2).", swed.fidat[ifno].fnam);
 	}
       }
-      return(ERR);
+      return(SE_ERR);
     } else
       return(OK);
   } else {
@@ -5023,7 +5023,7 @@ static int do_fread(void *trg, int size, int count, int corrsize, FILE *fp, int3
 	  sprintf(serr, "Ephemeris file %s is damaged (4).", swed.fidat[ifno].fnam);
 	}
       }
-      return(ERR);
+      return(SE_ERR);
     }
     if (size != corrsize) {
       memset((void *) targ, 0, (size_t) count * corrsize);
@@ -5261,7 +5261,7 @@ static int lunar_osc_elem(double tjd, int ipl, int32 iflag, char *serr)
   int i, j, istart;
   int ipli = SEI_MOON;
   int32 epheflag = SEFLG_DEFAULTEPH; 
-  int retc = ERR; 
+  int retc = SE_ERR; 
   int32 flg1, flg2;
   double daya[2];
 #if 0
@@ -5353,8 +5353,8 @@ static int lunar_osc_elem(double tjd, int ipl, int32 iflag, char *serr)
 	xp = xpos[i];
 	retc = jplplan(t, ipli, iflag, NO_SAVE, xp, NULL, NULL, serr);
 	/* read error or corrupt file */
-	if (retc == ERR)
-	  return(ERR);
+	if (retc == SE_ERR)
+	  return(SE_ERR);
 	/* light-time-corrected moon for apparent node 
 	 * this makes a difference of several milliarcseconds with
 	 * the node and 0.1" with the apogee.
@@ -5365,8 +5365,8 @@ static int lunar_osc_elem(double tjd, int ipl, int32 iflag, char *serr)
 	  dt = sqrt(square_sum(xpos[i])) * AUNIT / CLIGHT / 86400.0;     
 	  retc = jplplan(t-dt, ipli, iflag, NO_SAVE, xpos[i], NULL, NULL, serr);/**/
 	  /* read error or corrupt file */
-	  if (retc == ERR)
-	    return(ERR);
+	  if (retc == SE_ERR)
+	    return(SE_ERR);
         }
 	/* jpl ephemeris not on disk, or date beyond ephemeris range */
 	if (retc == NOT_AVAILABLE) {
@@ -5383,7 +5383,7 @@ static int lunar_osc_elem(double tjd, int ipl, int32 iflag, char *serr)
 	      strcat(serr, " \nusing Moshier Eph; ");
 	    break;
 	  } else
-	    return ERR;
+	    return SE_ERR;
 	}
 	/* precession and nutation etc. */
 	retc = swi_plan_for_osc_elem(iflag|SEFLG_SPEED, t, xpos[i]); /* retc is always ok */
@@ -5402,14 +5402,14 @@ static int lunar_osc_elem(double tjd, int ipl, int32 iflag, char *serr)
         else 
 	  t = tjd;
 	retc = swemoon(t, iflag | SEFLG_SPEED, NO_SAVE, xpos[i], serr);/**/
-	if (retc == ERR)
-	  return(ERR);
+	if (retc == SE_ERR)
+	  return(SE_ERR);
 	/* light-time-corrected moon for apparent node (~ 0.006") */
 	if ((iflag & SEFLG_TRUEPOS) == 0 && retc >= OK) { 
 	  dt = sqrt(square_sum(xpos[i])) * AUNIT / CLIGHT / 86400.0;     
 	  retc = swemoon(t-dt, iflag | SEFLG_SPEED, NO_SAVE, xpos[i], serr);/**/
-	  if (retc == ERR)
-	    return(ERR);
+	  if (retc == SE_ERR)
+	    return(SE_ERR);
         }
 	if (retc == NOT_AVAILABLE) {
 	  if (tjd > MOSHPLEPH_START && tjd < MOSHPLEPH_END) {
@@ -5419,7 +5419,7 @@ static int lunar_osc_elem(double tjd, int ipl, int32 iflag, char *serr)
 	      strcat(serr, " \nusing Moshier eph.; ");
 	    break;
 	  } else
-	    return ERR;
+	    return SE_ERR;
 	}
 	/* precession and nutation etc. */
 	retc = swi_plan_for_osc_elem(iflag|SEFLG_SPEED, t, xpos[i]); /* retc is always ok */
@@ -5440,7 +5440,7 @@ static int lunar_osc_elem(double tjd, int ipl, int32 iflag, char *serr)
         else 
 	  t = tjd;
 	retc = swi_moshmoon(t, NO_SAVE, xpos[i], serr);/**/
-	if (retc == ERR)
+	if (retc == SE_ERR)
 	  return(retc);
 #if 0
 	/* light-time-corrected moon for apparent node.
@@ -5650,8 +5650,8 @@ static int lunar_osc_elem(double tjd, int ipl, int32 iflag, char *serr)
        * sidereal code together */
       } else {
 	swi_cartpol_sp(ndp->xreturn+6, ndp->xreturn); 
-	if (swi_get_ayanamsa_with_speed(ndp->teval, iflag, daya, serr) == ERR)
-	  return ERR;
+	if (swi_get_ayanamsa_with_speed(ndp->teval, iflag, daya, serr) == SE_ERR)
+	  return SE_ERR;
 	ndp->xreturn[0] -= daya[0] * DEGTORAD;
 	ndp->xreturn[3] -= daya[1] * DEGTORAD;
 	swi_polcart_sp(ndp->xreturn, ndp->xreturn+6); 
@@ -5783,8 +5783,8 @@ static int intp_apsides(double tjd, int ipl, int32 iflag, char *serr)
     } else {
     /* traditional algorithm */
       swi_cartpol_sp(ndp->xreturn+6, ndp->xreturn); 
-      if (swi_get_ayanamsa_with_speed(ndp->teval, iflag, daya, serr) == ERR)
-        return ERR;
+      if (swi_get_ayanamsa_with_speed(ndp->teval, iflag, daya, serr) == SE_ERR)
+        return SE_ERR;
       ndp->xreturn[0] -= daya[0] * DEGTORAD;
       ndp->xreturn[3] -= daya[1] * DEGTORAD;
       swi_polcart_sp(ndp->xreturn, ndp->xreturn+6); 
@@ -6180,7 +6180,7 @@ static int32 plaus_iflag(int32 iflag, int32 ipl, double tjd, char *serr)
     iflag = iflag & ~(SEFLG_BARYCTR); 
   /* if heliocentric bit, turn aberration and deflection off */
   if (iflag & (SEFLG_HELCTR|SEFLG_BARYCTR)) 
-    iflag |= SEFLG_NOABERR | SEFLG_NOGDEFL; /*iflag |= SEFLG_TRUEPOS;*/
+    iflag |= SEFLG_NOABSE_ERR | SEFLG_NOGDEFL; /*iflag |= SEFLG_TRUEPOS;*/
   /* if no_precession bit is set, set also no_nutation bit */
   if (iflag & SEFLG_J2000)
     iflag |= SEFLG_NONUT;
@@ -6192,7 +6192,7 @@ static int32 plaus_iflag(int32 iflag, int32 ipl, double tjd, char *serr)
   }
   /* if truepos is set, turn off grav. defl. and aberration */
   if (iflag & SEFLG_TRUEPOS)
-    iflag |= (SEFLG_NOGDEFL | SEFLG_NOABERR);
+    iflag |= (SEFLG_NOGDEFL | SEFLG_NOABSE_ERR);
   if (iflag & SEFLG_MOSEPH)
     epheflag = SEFLG_MOSEPH;
   if (iflag & SEFLG_SWIEPH)
@@ -6263,7 +6263,7 @@ static int32 fixstar_format_search_name(char *star, char *sstar, char *serr)
   if (cmplen == 0) {
     if (serr != NULL)
       sprintf(serr, "swe_fixstar(): star name empty");
-    return ERR; 
+    return SE_ERR; 
   }
   return OK;
 }
@@ -6277,7 +6277,7 @@ static int32 save_star_in_struct(int nrecs, struct fixed_star *fstp, char *serr)
   char *serr_alloc = "error in function load_all_fixed_stars(): could not resize fixed stars array";
   if ((swed.fixed_stars = (struct fixed_star *) realloc(swed.fixed_stars, nrecs * sizestru)) == NULL) {
     if (serr != NULL) strcpy(serr, serr_alloc);
-    return ERR;
+    return SE_ERR;
   }
   ftarget = swed.fixed_stars + (nrecs - 1);
   memcpy((void *) ftarget, (void *) fstp, sizestru);
@@ -6326,7 +6326,7 @@ int32 fixstar_cut_string(char *srecord, char *star, struct fixed_star *stardata,
 	sprintf(serr, "invalid line in fixed stars file: '%s'", s);
       }
     }
-    return ERR;
+    return SE_ERR;
   }
   if (strlen(cpos[0]) > SWI_STAR_LENGTH)
     cpos[0][SWI_STAR_LENGTH] = '\0';
@@ -6408,7 +6408,7 @@ int32 fixstar_cut_string(char *srecord, char *star, struct fixed_star *stardata,
  * this name as its search key.
  * The array is sorted in ascending order by search key. 
  *
- * If an error occurs, the function returns value ERR.
+ * If an error occurs, the function returns value SE_ERR.
  * If the stars were loaded at an earlier time the function returns
  * value -2, without doing anything and without error string.
  * On success, the function returns value OK.
@@ -6431,7 +6431,7 @@ static int32 load_all_fixed_stars(char *serr)
       if ((swed.fixfp = swi_fopen(SEI_FILE_FIXSTAR, SE_STARFILE_OLD, swed.ephepath, NULL)) == NULL) {
 	swed.is_old_starfile = FALSE;
 	/* no fixed star file available, error message is already in serr. */
-	return ERR;
+	return SE_ERR;
       }
     }
   }
@@ -6447,7 +6447,7 @@ static int32 load_all_fixed_stars(char *serr)
     line++;
     strcpy(srecord, s);
     retc = fixstar_cut_string(srecord, NULL, &fstdata, serr);
-    if (retc == ERR) return ERR;
+    if (retc == SE_ERR) return SE_ERR;
     // if star has a traditional name, save it with that name as its search key
     if (*fstdata.starname != '\0') {
       nrecs++;
@@ -6459,7 +6459,7 @@ static int32 load_all_fixed_stars(char *serr)
       // star name to lowercase and compare with search string
       for (sp = fstdata.skey; *sp != '\0'; sp++) 
 	*sp = tolower((int) *sp);
-      if ((retc = save_star_in_struct(nrecs, &fstdata, serr)) == ERR) return ERR;
+      if ((retc = save_star_in_struct(nrecs, &fstdata, serr)) == SE_ERR) return SE_ERR;
     }
     // also save it with Bayer designation as search key;
     // only if it has not been saved already
@@ -6473,11 +6473,11 @@ static int32 load_all_fixed_stars(char *serr)
     while ((sp = strchr(fstdata.skey, ' ')) != NULL)
       swi_strcpy(sp, sp+1);
     strcpy(last_starbayer, fstdata.starbayer);
-    if ((retc = save_star_in_struct(nrecs, &fstdata, serr)) == ERR) return ERR;
+    if ((retc = save_star_in_struct(nrecs, &fstdata, serr)) == SE_ERR) return SE_ERR;
     // also save it with sequential star number as search key (NO!!!!)
     // nrecs++;
     // sprintf(fstdata.skey, "%07d", nstars);
-    // if ((retc = save_star_in_struct(nrecs, &fstdata, serr)) == ERR) return ERR;
+    // if ((retc = save_star_in_struct(nrecs, &fstdata, serr)) == SE_ERR) return SE_ERR;
   }
   swed.n_fixstars_real = nstars;
   swed.n_fixstars_named = nnamed;
@@ -6593,10 +6593,10 @@ static int32 fixstar_calc_from_struct(struct fixed_star *stardata, double tjd, i
    ****************************************************/
   if (!(iflag & SEFLG_BARYCTR) && (!(iflag & SEFLG_HELCTR) || !(iflag & SEFLG_MOSEPH))) {
     if ((retc =  main_planet_bary(tjd - dt, SEI_EARTH, epheflag, iflag, NO_SAVE, xearth_dt, xearth_dt, xsun_dt, NULL, serr)) != OK) {
-      return ERR;
+      return SE_ERR;
     }
     if ((retc =  main_planet_bary(tjd, SEI_EARTH, epheflag, iflag, DO_SAVE, xearth, xearth, xsun, NULL, serr)) != OK) {
-      return ERR;
+      return SE_ERR;
     }
   }
   /************************************
@@ -6605,9 +6605,9 @@ static int32 fixstar_calc_from_struct(struct fixed_star *stardata, double tjd, i
   /* if topocentric position is wanted  */
   if (iflag & SEFLG_TOPOCTR) { 
     if (swi_get_observer(tjd - dt, iflag | SEFLG_NONUT, NO_SAVE, xobs_dt, serr) != OK)
-      return ERR;
+      return SE_ERR;
     if (swi_get_observer(tjd, iflag | SEFLG_NONUT, NO_SAVE, xobs, serr) != OK)
-      return ERR;
+      return SE_ERR;
     /* barycentric position of observer */
     for (i = 0; i <= 5; i++) {
       xobs[i] = xobs[i] + xearth[i];	
@@ -6658,7 +6658,7 @@ static int32 fixstar_calc_from_struct(struct fixed_star *stardata, double tjd, i
    * 'annual' aberration of light   *
    * speed is incorrect !!!         *
    **********************************/
-  if ((iflag & SEFLG_TRUEPOS) == 0 && (iflag & SEFLG_NOABERR) == 0)
+  if ((iflag & SEFLG_TRUEPOS) == 0 && (iflag & SEFLG_NOABSE_ERR) == 0)
     swi_aberr_light_ex(x, xpo, xpo_dt, dt, iflag & SEFLG_SPEED);
   /* ICRS to J2000 */
   if (!(iflag & SEFLG_ICRS) && (swi_get_denum(SEI_SUN, iflag) >= 403 || (iflag & SEFLG_BARYCTR))) {
@@ -6710,7 +6710,7 @@ if ((0)) {
     /* rigorous algorithm */
     if (swed.sidd.sid_mode & SE_SIDBIT_ECL_T0) {
       if (swi_trop_ra2sid_lon(xxsv, x, xxsv, iflag) != OK)
-        return ERR;
+        return SE_ERR;
       if (iflag & SEFLG_EQUATORIAL) {
         for (i = 0; i <= 5; i++)
           x[i] = xxsv[i];
@@ -6718,7 +6718,7 @@ if ((0)) {
     /* project onto solar system equator */
     } else if (swed.sidd.sid_mode & SE_SIDBIT_SSY_PLANE) {
       if (swi_trop_ra2sid_lon_sosy(xxsv, x, iflag) != OK)
-	return ERR;
+	return SE_ERR;
       if (iflag & SEFLG_EQUATORIAL) {
         for (i = 0; i <= 5; i++)
           x[i] = xxsv[i];
@@ -6727,8 +6727,8 @@ if ((0)) {
     } else {
       swi_cartpol_sp(x, x); 
       // ACHTUNG: siehe Z. 2770!!!!!
-      if (swi_get_ayanamsa_with_speed(tjd, iflag, daya, serr) == ERR)
-        return ERR;
+      if (swi_get_ayanamsa_with_speed(tjd, iflag, daya, serr) == SE_ERR)
+        return SE_ERR;
       x[0] -= daya[0] * DEGTORAD;
       x[3] -= daya[1] * DEGTORAD;
       swi_polcart_sp(x, x); 
@@ -6786,7 +6786,7 @@ static int32 search_star_in_list(char *sstar, struct fixed_star *stardata, char
     if (star_nr > swed.n_fixstars_real) {
       if (serr != NULL) 
 	sprintf(serr, "error, swe_fixstar(): sequential fixed star number %d is not available", star_nr);
-      return ERR;
+      return SE_ERR;
     }
     *stardata = swed.fixed_stars[star_nr - 1]; // keys start from 1
     //printf("seq.number: %s, %s, %s, %f\n", stardata.skey, stardata.starname, stardata.starbayer, stardata.mag);
@@ -6798,7 +6798,7 @@ static int32 search_star_in_list(char *sstar, struct fixed_star *stardata, char
     if (sp - sstar != strlen(sstar) - 1) {
       if (serr != NULL)
 	sprintf(serr, "error, swe_fixstar(): invalid search string %s", sstar);
-      return ERR;
+      return SE_ERR;
     }
     strcpy(searchkey, sstar);
     len = (int) (strlen(sstar) - 1);
@@ -6811,7 +6811,7 @@ static int32 search_star_in_list(char *sstar, struct fixed_star *stardata, char
     }
     if (serr != NULL)
       sprintf(serr, "error, swe_fixstar(): star search string %s did not match", sstar);
-    return ERR;
+    return SE_ERR;
   /* traditional name or Bayer/Flamsteed: find it with binary search */
   } else {
     strcpy(searchkey, sstar);
@@ -6832,7 +6832,7 @@ static int32 search_star_in_list(char *sstar, struct fixed_star *stardata, char
     if (stardatap == NULL) {
       if (serr != NULL) 
 	sprintf(serr, "error, swe_fixstar(): could not find star name %s", sstar);
-      return ERR;
+      return SE_ERR;
     }
     *stardata = *stardatap;
     //printf("name search: %s, %s, %s, %f\n", stardata.skey, stardata.starname, stardata.starbayer, stardata.mag);
@@ -6934,7 +6934,7 @@ for (i = 0; i < swed.n_fixstars_records; i++) {
 exit(0);
 #endif
   retc = fixstar_format_search_name(star, sstar, serr);
-  if (retc == ERR)
+  if (retc == SE_ERR)
     goto return_err;
   /* star elements from last call: */
   if (swed.n_fixstars_records > 0 && strcmp(slast_starname, sstar) == 0) {
@@ -6952,14 +6952,14 @@ exit(0);
   /* sequential fixed star number: get it from array directly */
   } 
   retc = search_star_in_list(sstar, &stardata, serr);
-  if (retc == ERR)
+  if (retc == SE_ERR)
     goto return_err;
   /******************************************************/
   found:
   //strcpy(slast_stardata, srecord);
   last_stardata = stardata;
   strcpy(slast_starname, sstar);
-  if ((retc = fixstar_calc_from_struct(&stardata, tjd, iflag, star, xx, serr)) == ERR)
+  if ((retc = fixstar_calc_from_struct(&stardata, tjd, iflag, star, xx, serr)) == SE_ERR)
     goto return_err;
 #ifdef TRACE
   trace_swe_fixstar(2, star, tjd, iflag, xx, serr);
@@ -6989,7 +6989,7 @@ int32 CALL_CONV swe_fixstar2_ut(char *star, double tjd_ut, int32 iflag,
   deltat = swe_deltat_ex(tjd_ut, iflag, serr);
   /* if ephe required is not ephe returned, adjust delta t: */
   retflag = swe_fixstar2(star, tjd_ut + deltat, iflag, xx, serr);
-  if (retflag != ERR && (retflag & SEFLG_EPHMASK) != epheflag) {
+  if (retflag != SE_ERR && (retflag & SEFLG_EPHMASK) != epheflag) {
     deltat = swe_deltat_ex(tjd_ut, retflag, NULL);
     retflag = swe_fixstar2(star, tjd_ut + deltat, iflag, xx, NULL);
   }
@@ -7019,7 +7019,7 @@ int32 CALL_CONV swe_fixstar2_mag(char *star, double *mag, char *serr)
     *serr = '\0';
   load_all_fixed_stars(serr); // loads stars unless loaded with an earlier call of function
   retc = fixstar_format_search_name(star, sstar, serr);
-  if (retc == ERR)
+  if (retc == SE_ERR)
     goto return_err;
   /* star elements from last call: */
   if (swed.n_fixstars_records > 0 && strcmp(slast_starname, sstar) == 0) {
@@ -7028,7 +7028,7 @@ int32 CALL_CONV swe_fixstar2_mag(char *star, double *mag, char *serr)
     goto found;
   }
   retc = search_star_in_list(sstar, &stardata, serr);
-  if (retc == ERR)
+  if (retc == SE_ERR)
     goto return_err;
   /******************************************************/
   found:
@@ -7150,7 +7150,7 @@ char *CALL_CONV swe_get_planet_name(int ipl, char *s)
         /* else try to get it from ephemeris file */
 	} else {
 	  retc = sweph(J2000, ipl, SEI_FILE_ANY_AST, 0, NULL, NO_SAVE, xp, NULL);
-	  if (retc != ERR && retc != NOT_AVAILABLE) {
+	  if (retc != SE_ERR && retc != NOT_AVAILABLE) {
 	    strcpy(s, swed.fidat[SEI_FILE_ANY_AST].astnam);
 	  } else {
 	    if (ipl > SE_AST_OFFSET)
@@ -7388,7 +7388,7 @@ int swi_get_observer(double tjd, int32 iflag,
   if (!swed.geopos_is_set) {
     if (serr != NULL)
       strcpy(serr, "geographic position has not been set");
-    return ERR;
+    return SE_ERR;
   }
   /* geocentric position of observer depends on sidereal time,
    * which depends on UT. 
@@ -7498,9 +7498,9 @@ int32 CALL_CONV swe_time_equ(double tjd_ut, double *E, char *serr)
   dt = t - floor(t);
   sidt -= dt * 24;
   sidt *= 15;
-  if ((retval = swe_calc_ut(tjd_ut, SE_SUN, iflag, x, serr)) == ERR) {
+  if ((retval = swe_calc_ut(tjd_ut, SE_SUN, iflag, x, serr)) == SE_ERR) {
     *E = 0;
-    return ERR;
+    return SE_ERR;
   }
   dt = swe_degnorm(sidt - x[0] - 180);
   if (dt > 180)
@@ -7586,8 +7586,8 @@ static int32 swi_fixstar_load_record(char *star, char *srecord, char *sname, cha
    * - traditional name to lower case (Bayer designation remains as it is)
    */
   retc = fixstar_format_search_name(star, sstar, serr);
-  if (retc == ERR)
-    return ERR;
+  if (retc == SE_ERR)
+    return SE_ERR;
   // search name is Bayer designation
   if (*sstar == ',') {
     is_bayer = TRUE;
@@ -7613,7 +7613,7 @@ static int32 swi_fixstar_load_record(char *star, char *srecord, char *sname, cha
       if ((swed.fixfp = swi_fopen(SEI_FILE_FIXSTAR, SE_STARFILE_OLD, swed.ephepath, NULL)) == NULL) {
 	swed.is_old_starfile = FALSE;
 	/* no fixed star file available, error message is already in serr. */
-	return ERR;
+	return SE_ERR;
       }
     }
   }
@@ -7633,7 +7633,7 @@ static int32 swi_fixstar_load_record(char *star, char *srecord, char *sname, cha
       if (serr != NULL) {
 	sprintf(serr, "star file %s damaged at line %d", SE_STARFILE, fline);
       }
-      return ERR;
+      return SE_ERR;
     } 
     // search string is Bayer or Flamsteed designation
     if (is_bayer) {
@@ -7669,12 +7669,12 @@ static int32 swi_fixstar_load_record(char *star, char *srecord, char *sname, cha
     if (strlen(serr) + strlen(star) < AS_MAXCH) {
       sprintf(serr, "star %s not found", star);
     }
-    return ERR;
+    return SE_ERR;
   }
   found:
   strcpy(srecord, s);
   retc = fixstar_cut_string(srecord, star, &stardata, serr);
-  if (retc == ERR) return ERR;
+  if (retc == SE_ERR) return SE_ERR;
   if (dparams != NULL) {
     dparams[0] = stardata.epoch; // epoch
     // RA(epoch)
@@ -7755,7 +7755,7 @@ static int32 swi_fixstar_calc_from_record(char *srecord, double tjd, int32 iflag
    ******************************************/
   swi_check_nutation(tjd, iflag);
   retc = fixstar_cut_string(srecord, star, &stardata, serr);
-  if (retc == ERR) return ERR;
+  if (retc == SE_ERR) return SE_ERR;
   epoch = stardata.epoch;
   ra_pm = stardata.ramot; de_pm = stardata.demot;
   radv = stardata.radvel; parall = stardata.parall; 
@@ -7803,10 +7803,10 @@ static int32 swi_fixstar_calc_from_record(char *srecord, double tjd, int32 iflag
    ****************************************************/
   if (!(iflag & SEFLG_BARYCTR) && (!(iflag & SEFLG_HELCTR) || !(iflag & SEFLG_MOSEPH))) {
     if ((retc =  main_planet_bary(tjd - dt, SEI_EARTH, epheflag, iflag, NO_SAVE, xearth_dt, xearth_dt, xsun_dt, NULL, serr)) != OK) {
-      return ERR;
+      return SE_ERR;
     }
     if ((retc =  main_planet_bary(tjd, SEI_EARTH, epheflag, iflag, DO_SAVE, xearth, xearth, xsun, NULL, serr)) != OK) {
-      return ERR;
+      return SE_ERR;
     }
   }
   /************************************
@@ -7815,9 +7815,9 @@ static int32 swi_fixstar_calc_from_record(char *srecord, double tjd, int32 iflag
   /* if topocentric position is wanted  */
   if (iflag & SEFLG_TOPOCTR) { 
     if (swi_get_observer(tjd - dt, iflag | SEFLG_NONUT, NO_SAVE, xobs_dt, serr) != OK)
-      return ERR;
+      return SE_ERR;
     if (swi_get_observer(tjd, iflag | SEFLG_NONUT, NO_SAVE, xobs, serr) != OK)
-      return ERR;
+      return SE_ERR;
     /* barycentric position of observer */
     for (i = 0; i <= 5; i++) {
       xobs[i] = xobs[i] + xearth[i];	
@@ -7872,7 +7872,7 @@ static int32 swi_fixstar_calc_from_record(char *srecord, double tjd, int32 iflag
    * 'annual' aberration of light   *
    * speed is incorrect !!!         *
    **********************************/
-  if ((iflag & SEFLG_TRUEPOS) == 0 && (iflag & SEFLG_NOABERR) == 0)
+  if ((iflag & SEFLG_TRUEPOS) == 0 && (iflag & SEFLG_NOABSE_ERR) == 0)
     swi_aberr_light_ex(x, xpo, xpo_dt, dt, iflag & SEFLG_SPEED);
   /* ICRS to J2000 */
   if (!(iflag & SEFLG_ICRS) && (swi_get_denum(SEI_SUN, iflag) >= 403 || (iflag & SEFLG_BARYCTR))) {
@@ -7925,7 +7925,7 @@ if ((0)) {
     /* rigorous algorithm */
     if (swed.sidd.sid_mode & SE_SIDBIT_ECL_T0) {
       if (swi_trop_ra2sid_lon(xxsv, x, xxsv, iflag) != OK)
-        return ERR;
+        return SE_ERR;
       if (iflag & SEFLG_EQUATORIAL) {
         for (i = 0; i <= 5; i++)
           x[i] = xxsv[i];
@@ -7933,7 +7933,7 @@ if ((0)) {
     /* project onto solar system equator */
     } else if (swed.sidd.sid_mode & SE_SIDBIT_SSY_PLANE) {
       if (swi_trop_ra2sid_lon_sosy(xxsv, x, iflag) != OK)
-	return ERR;
+	return SE_ERR;
       if (iflag & SEFLG_EQUATORIAL) {
         for (i = 0; i <= 5; i++)
           x[i] = xxsv[i];
@@ -7941,8 +7941,8 @@ if ((0)) {
     /* traditional algorithm */
     } else {
       swi_cartpol_sp(x, x); 
-      if (swi_get_ayanamsa_ex(tjd, iflag, &daya, serr) == ERR)
-        return ERR;
+      if (swi_get_ayanamsa_ex(tjd, iflag, &daya, serr) == SE_ERR)
+        return SE_ERR;
       x[0] -= daya * DEGTORAD;
       swi_polcart_sp(x, x); 
     }
@@ -8003,7 +8003,7 @@ int32 CALL_CONV swe_fixstar(char *star, double tjd, int32 iflag,
   trace_swe_fixstar(1, star, tjd, iflag, xx, serr);
 #endif /* TRACE */
   retc = fixstar_format_search_name(star, sstar, serr);
-  if (retc == ERR)
+  if (retc == SE_ERR)
     goto return_err;
   if (*sstar == ',') {
     ; // is Bayer designation
@@ -8033,7 +8033,7 @@ int32 CALL_CONV swe_fixstar(char *star, double tjd, int32 iflag,
   found:
   strcpy(slast_stardata, srecord);
   strcpy(slast_starname, sstar);
-  if ((retc = swi_fixstar_calc_from_record(srecord, tjd, iflag, star, xx, serr)) == ERR)
+  if ((retc = swi_fixstar_calc_from_record(srecord, tjd, iflag, star, xx, serr)) == SE_ERR)
     goto return_err;
 #ifdef TRACE
   trace_swe_fixstar(2, star, tjd, iflag, xx, serr);
@@ -8063,7 +8063,7 @@ int32 CALL_CONV swe_fixstar_ut(char *star, double tjd_ut, int32 iflag,
   deltat = swe_deltat_ex(tjd_ut, iflag, serr);
   /* if ephe required is not ephe returned, adjust delta t: */
   retflag = swe_fixstar(star, tjd_ut + deltat, iflag, xx, serr);
-  if (retflag != ERR && (retflag & SEFLG_EPHMASK) != epheflag) {
+  if (retflag != SE_ERR && (retflag & SEFLG_EPHMASK) != epheflag) {
     deltat = swe_deltat_ex(tjd_ut, retflag, NULL);
     retflag = swe_fixstar(star, tjd_ut + deltat, iflag, xx, NULL);
   }
@@ -8093,7 +8093,7 @@ int32 CALL_CONV swe_fixstar_mag(char *star, double *mag, char *serr)
   if (serr != NULL)
     *serr = '\0';
   retc = fixstar_format_search_name(star, sstar, serr);
-  if (retc == ERR)
+  if (retc == SE_ERR)
     goto return_err;
   if (*sstar == ',') {
     ; // is Bayer designation
@@ -8107,7 +8107,7 @@ int32 CALL_CONV swe_fixstar_mag(char *star, double *mag, char *serr)
   if (*slast_stardata != '\0' && strcmp(slast_starname, sstar) == 0) {
     strcpy(srecord, slast_stardata);
     retc = fixstar_cut_string(srecord, star, &stardata, serr);
-    if (retc == ERR) goto return_err;
+    if (retc == SE_ERR) goto return_err;
     // magnitude V
     dparams[7] = stardata.mag;
     goto found;
@@ -8144,7 +8144,7 @@ int32 CALL_CONV swe_calc_pctr(double tjd, int32 ipl, int32 iplctr, int32 iflag,
   if (ipl == iplctr) {
     if (serr != NULL) 
 	  sprintf(serr, "ipl and iplctr (= %d) must not be identical\n", ipl);
-	return ERR;
+	return SE_ERR;
   }
   iflag = plaus_iflag(iflag, ipl, tjd, serr);
   epheflag = iflag & SEFLG_EPHMASK;
@@ -8153,13 +8153,13 @@ int32 CALL_CONV swe_calc_pctr(double tjd, int32 ipl, int32 iplctr, int32 iflag,
   iflag &= ~(SEFLG_HELCTR|SEFLG_BARYCTR);
   iflag2 = epheflag;
   iflag2 |= (SEFLG_BARYCTR|SEFLG_J2000|SEFLG_ICRS|SEFLG_TRUEPOS|SEFLG_EQUATORIAL|SEFLG_XYZ|SEFLG_SPEED);
-  iflag2 |= (SEFLG_NOABERR|SEFLG_NOGDEFL);
+  iflag2 |= (SEFLG_NOABSE_ERR|SEFLG_NOGDEFL);
   retc = swe_calc(tjd, iplctr, iflag2, xxctr, serr);
-  if (retc == ERR) 
-    return ERR;
+  if (retc == SE_ERR) 
+    return SE_ERR;
   retc = swe_calc(tjd, ipl, iflag2, xx, serr);
-  if (retc == ERR) 
-    return ERR;
+  if (retc == SE_ERR) 
+    return SE_ERR;
   for (i = 0; i <= 5; i++) {
     xx0[i] = xx[i];
     //xx[i] -= xxctr[i];
@@ -8247,8 +8247,8 @@ int32 CALL_CONV swe_calc_pctr(double tjd, int32 ipl, int32 iplctr, int32 iflag,
   /**********************************
    * 'annual' aberration of light   *
    **********************************/
-  if (!(iflag & SEFLG_TRUEPOS) && !(iflag & SEFLG_NOABERR)) {
-    	/* SEFLG_NOABERR is on, if SEFLG_HELCTR or SEFLG_BARYCTR */
+  if (!(iflag & SEFLG_TRUEPOS) && !(iflag & SEFLG_NOABSE_ERR)) {
+    	/* SEFLG_NOABSE_ERR is on, if SEFLG_HELCTR or SEFLG_BARYCTR */
     swi_aberr_light(xx, xxctr, iflag);
     /* 
      * Apparent speed is also influenced by
@@ -8312,11 +8312,11 @@ int32 CALL_CONV swe_calc_pctr(double tjd, int32 ipl, int32 iplctr, int32 iflag,
     /* project onto ecliptic t0 */
     if (swed.sidd.sid_mode & SE_SIDBIT_ECL_T0) {
       if (swi_trop_ra2sid_lon(xxsv, xreturn+6, xreturn+18, iflag) != OK)
-	return ERR;
+	return SE_ERR;
     /* project onto solar system equator */
     } else if (swed.sidd.sid_mode & SE_SIDBIT_SSY_PLANE) {
       if (swi_trop_ra2sid_lon_sosy(xxsv, xreturn+6, iflag) != OK)
-        return ERR;
+        return SE_ERR;
     } else {
     /* traditional algorithm */
       swi_cartpol_sp(xreturn+6, xreturn); 
@@ -8325,8 +8325,8 @@ int32 CALL_CONV swe_calc_pctr(double tjd, int32 ipl, int32 iplctr, int32 iflag,
        * Therefore current values are saved... */
       for (i = 0; i < 24; i++)
         xxsv[i] = xreturn[i];
-      if (swi_get_ayanamsa_with_speed(tjd, iflag, daya, serr) == ERR)
-        return ERR;
+      if (swi_get_ayanamsa_with_speed(tjd, iflag, daya, serr) == SE_ERR)
+        return SE_ERR;
       /* ... and restored */
       for (i = 0; i < 24; i++)
         xreturn[i] = xxsv[i];
@@ -8371,8 +8371,8 @@ int32 CALL_CONV swe_calc_pctr(double tjd, int32 ipl, int32 iplctr, int32 iflag,
 	xxret[i] *= DEGTORAD;
     }
   }
-  if (retc == ERR)
-    return ERR;
+  if (retc == SE_ERR)
+    return SE_ERR;
   return(iflag);
 }
 
diff --git a/src/libswe/sweph.h b/src/libswe/sweph.h
index 0091d77..f098032 100644
--- a/src/libswe/sweph.h
+++ b/src/libswe/sweph.h
@@ -112,7 +112,7 @@
 #define SE_NAME_ISIS            "Isis"
 #define SE_NAME_NIBIRU          "Nibiru"
 #define SE_NAME_HARRINGTON      "Harrington"
-#define SE_NAME_NEPTUNE_LEVERRIER       "Leverrier"
+#define SE_NAME_NEPTUNE_LEVSE_ERRIER       "Leverrier"
 #define SE_NAME_NEPTUNE_ADAMS   "Adams"
 #define SE_NAME_PLUTO_LOWELL    "Lowell"
 #define SE_NAME_PLUTO_PICKERING "Pickering"
@@ -249,7 +249,7 @@
 #define NCTIES         6.0     /* number of centuries per eph. file */
 
 #define OK (0)
-#define ERR (-1)
+#define SE_ERR (-1)
 #define NOT_AVAILABLE (-2)
 #define BEYOND_EPH_LIMITS (-3)
 
diff --git a/src/libswe/swephexp.h b/src/libswe/swephexp.h
index bda3a4b..631a79a 100644
--- a/src/libswe/swephexp.h
+++ b/src/libswe/swephexp.h
@@ -150,7 +150,7 @@ extern "C" {
 #define SE_ISIS         	48
 #define SE_NIBIRU       	49
 #define SE_HARRINGTON           50
-#define SE_NEPTUNE_LEVERRIER    51
+#define SE_NEPTUNE_LEVSE_ERRIER    51
 #define SE_NEPTUNE_ADAMS        52
 #define SE_PLUTO_LOWELL         53
 #define SE_PLUTO_PICKERING      54
@@ -195,8 +195,8 @@ extern "C" {
                                 * SEFLG_SPEED is faster and more precise.) */
 #define SEFLG_SPEED	256    /* high precision speed  */
 #define SEFLG_NOGDEFL	512    /* turn off gravitational deflection */
-#define SEFLG_NOABERR	1024   /* turn off 'annual' aberration of light */
-#define SEFLG_ASTROMETRIC (SEFLG_NOABERR|SEFLG_NOGDEFL) /* astrometric position,
+#define SEFLG_NOABSE_ERR	1024   /* turn off 'annual' aberration of light */
+#define SEFLG_ASTROMETRIC (SEFLG_NOABSE_ERR|SEFLG_NOGDEFL) /* astrometric position,
                                 * i.e. with light-time, but without aberration and
 			        * light deflection */
 #define SEFLG_EQUATORIAL (2*1024)    /* equatorial positions are wanted */
diff --git a/src/libswe/swephlib.c b/src/libswe/swephlib.c
index 1a45696..5de9f80 100644
--- a/src/libswe/swephlib.c
+++ b/src/libswe/swephlib.c
@@ -2141,15 +2141,15 @@ int swi_nutation(double tjd, int32 iflag, double *nutlo)
       swed.interpol.tjd_nut0 = tjd - 1.0; // one day earlier
       swed.interpol.tjd_nut2 = tjd + 1.0; // one day later
       retc = calc_nutation(swed.interpol.tjd_nut0, iflag, dnut);
-      if (retc == ERR) return ERR;
+      if (retc == SE_ERR) return SE_ERR;
       swed.interpol.nut_dpsi0 = dnut[0];
       swed.interpol.nut_deps0 = dnut[1];
       retc = calc_nutation(swed.interpol.tjd_nut2, iflag, dnut);
-      if (retc == ERR) return ERR;
+      if (retc == SE_ERR) return SE_ERR;
       swed.interpol.nut_dpsi2 = dnut[0];
       swed.interpol.nut_deps2 = dnut[1];
       retc = calc_nutation(tjd, iflag, nutlo);
-      if (retc == ERR) return ERR;
+      if (retc == SE_ERR) return SE_ERR;
       swed.interpol.nut_dpsi1 = nutlo[0];
       swed.interpol.nut_deps1 = nutlo[1];
     }
